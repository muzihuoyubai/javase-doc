

#  引言

## 前置知识
学习本次课程需要
* 具备线程、进程、多线程基本概念
* 对并发模型有基本的了解

## 学习目的
应用程序中使用多线程的一些最常见原因是：
1. 更好地利用CPU  
最常见的原因之一是能够更好地利用计算机中的资源。例如，如果一个线程正在等待对通过网络发送的请求的响应，则另一线程可以同时使用CPU来执行其他操作。此外，如果计算机具有多个CPU，或者CPU具有多个执行核心，则多线程还可以帮助应用程序利用这些额外的CPU核心。
2. 提高响应能力获得更好的用户体验  
如果单击应用程序中的按钮，触发文件读取或网络传输等比较耗时的动作，我们更希望这样的动作可以由线程在后台执行，这样按钮可以快速对用户点击做出反馈，用户的体验更好。而不是等待动作完成之后反馈，这样给用户的感觉是程序在点击按钮之后卡顿了一段时间之后才有反映。
3. 公平的服务多用户  
多线程可以帮助用户之间更公平地共享计算机资源。例如，假设一台服务器接收来自客户端的请求，并且客户端发送的请求要花很长时间才能处理完成，如果只有一个线程来执行这些请求，那么所有其他客户端的请求都必须等待，直到前一个客户端请求完成。通过让每个客户端的请求都由一个独立的线程执行，来避免一个任务完全垄断CPU。


## 课程结构


## 学习目标
经过本次课学习，可以达到
* 可以创建多线程程序
* 了解多线程程序运行时可能出现的问题以及规避方式

# 获取线程信息

## 线程状态

在Java中，程序运行需要首先启动java虚拟机，一个运行的java虚拟机对应一个java程序进程，而线程位于同一个JVM中，并且可以由Java应用程序在运行时动态创建和停止。每个程序至少有一个线程：主线程。这个主线程是在每个Java应用程序启动期间创建的，它是调用main()程序方法的那个线程。从这个线程开始，Java应用程序可以创建新的线程并使用它们。

每个线程都有一个标识符，该标识符在JVM中是唯一的。线程的名称有助于在监视运行中的JVM的外部应用程序（例如调试器或JConsole工具）中找到某些线程。当执行多个线程时，优先级决定下一个应该执行的任务。

并非所有线程实际上都同时执行，而是将每个CPU内核上的执行时间划分为小片，并将下一个时间片分配给具有最高优先级的下一个等待线程。JVM的调度程序根据线程的优先级确定下一个要执行的线程。

在优先级旁边，线程还具有状态，可以是以下状态之一：

* NEW: 尚未启动的线程处于此状态.
* RUNNABLE: 在Java虚拟机中执行的线程处于此状态。
* BLOCKED: 处于等待监视器锁定状态的被阻塞线程处于此状态。
* WAITING: 无限期等待另一个线程执行特定操作的线程处于此状态。
* TIMED_WAITING: 个正在等待另一个线程执行操作的线程最多达到指定的等待时间，该线程处于此状态。
* TERMINATED: 退出的线程处于此状态。



## 显示主线程相关信息

```
public class MainThread {
     
    public static void main(String[] args) {
        long id = Thread.currentThread().getId();
        String name = Thread.currentThread().getName();
        int priority = Thread.currentThread().getPriority();
        State state = Thread.currentThread().getState();
        String threadGroupName = Thread.currentThread().getThreadGroup().getName();
        System.out.println("id="+id+"; name="+name+"; priority="+priority+"; state="+state+"; threadGroupName="+threadGroupName);
    }
```

## Thread常用API

### 常见陷阱：调用run（）而不是start（）
创建和启动线程时，常见的错误是调用而不是的run()方法，如下所示： Threadstart()

```
 Thread newThread = new Thread(MyRunnable());
  newThread.run();  //should be start();
```
刚开始您可能不会注意到任何事情，因为Runnable的run()方法按预期执行。但是，它不会由您刚刚创建的新线程执行。而是run()由创建线程的线程执行该方法。换句话说，该线程执行了以上两行代码。要使新创建的线程调用实例的 run()方法，必须调用该方法。 MyRunnablenewThreadnewThread.start()

### 线程名称
创建Java线程时，可以为其命名。该名称可以帮助您区分不同的线程。例如，如果有多个线程写入， System.out可以很方便地查看哪个线程写入了文本。这是一个例子：

```
 Thread thread = new Thread("New Thread") {
      public void run(){
        System.out.println("run by: " + getName());
      }
   };


   thread.start();
   System.out.println(thread.getName());
```


注意作为参数传递给Thread构造函数的字符串“ New Thread” 。此字符串是线程的名称。可以通过Thread的getName()方法获取名称。您也可以Thread在使用Runnable实现时将名称传递给。看起来是这样的：

```
 MyRunnable runnable = new MyRunnable();
   Thread thread = new Thread(runnable, "New Thread");

   thread.start();
   System.out.println(thread.getName());
```

但是请注意，由于MyRunnable该类不是的子类 Thread，因此它无权访问getName()执行它的线程的方法。

### Thread.currentThread（）
该Thread.currentThread()方法返回对Thread执行实例 的引用currentThread()。这样，您可以访问Thread代表执行给定代码块的线程的Java 对象。这是一个使用方法的例子Thread.currentThread()：

```
Thread thread = Thread.currentThread();
```
一旦有了对Thread对象的引用，就可以在其上调用方法。例如，您可以获取当前正在执行代码的线程的名称，如下所示：

```
 String threadName = Thread.currentThread().getName();
```
## Java线程示例
这是一个小例子。首先，它打印出执行该main()方法的线程的名称。该线程由JVM分配。然后启动10个线程，并给它们一个全名（"" + i）。然后，每个线程将其名称打印出来，然后停止执行。

```
public class ThreadExample {

  public static void main(String[] args){
    System.out.println(Thread.currentThread().getName());
    for(int i=0; i<10; i++){
      new Thread("" + i){
        public void run(){
          System.out.println("Thread: " + getName() + " running");
        }
      }.start();
    }
  }
}
```

请注意，即使线程按顺序启动（1、2、3等），它们也可能不会顺序执行，这意味着线程1可能不是第一个将其名称写入的线程System.out。这是因为线程原则上是并行执行而不是顺序执行。JVM和/或操作系统确定线程的执行顺序。此顺序不必与开始时的顺序相同。


# 创建和启动Java线程
创建和启动线程
用Java创建线程是这样完成的：

```
Thread thread = new Thread();
```

要启动Java线程，将调用其start()方法，如下所示：

```
thread.start();
```

本示例未指定要线程需要执行任何代码。因此，线程在启动后将立即再次停止。

有两种方法可以指定线程需要执行的代码。第一种是创建`Thread`的子类并覆盖该`run()`方法。第二种方法是将实现的对象`Runnable` （java.lang.Runnable传递给 `Thread`构造函数。下面介绍这两种方法。

## Thread子类
指定线程运行什么代码的第一种方法是创建Thread的子类并重写该`run()`方法。该run()方法是调用后线程执行的操作start()。这是创建Java Thread子类的示例：

```
 public class MyThread extends Thread {

    public void run(){
       System.out.println("MyThread running");
    }
  }
```
要创建并启动上述线程，您可以执行以下操作：

```
MyThread myThread = new MyThread();
  myTread.start();
```
start()线程启动后 ，调用将立即返回。它不会等到run()方法完成。该`run()`方法像启动了另一个程序一样开始执行。该run()方法执行时，将打印出文本“ MyThread running”。

您也可以创建一个匿名子类，Thread如下所示：
```
Thread thread = new Thread(){
    public void run(){
      System.out.println("Thread Running");
    }
  }

  thread.start();
```
一旦run()新线程执行了该方法，此示例将打印出文本“ Thread running” 。

### 使用接口创建线程
指定线程应运行什么代码的第二种方法是通过创建实现该java.lang.Runnable接口的类。实现该Runnable接口的Java对象 可以由Java执行Thread。本教程的稍后部分将介绍如何完成此操作。

该Runnable接口是Java平台随附的标准Java接口。该Runnable接口只有一个方法run()。Runnable界面基本上是这样的：

```
public interface Runnable() {

    public void run();

}
```

该run()方法的实现中必须包括线程在执行时应该执行的操作。有三种实现Runnable接口的方法：

* 创建一个实现该Runnable接口的Java类。
* 创建一个实现该Runnable接口的匿名类。
* 创建一个实现Runnable接口的Java Lambda 。

以下各节将说明所有这三个选项。

#### Java类实现可运行  
实现Java Runnable接口的第一种方法是创建自己的实现该Runnable接口的Java类。这是实现Runnable接口的自定义Java类的示例：

```
 public class MyRunnable implements Runnable {

    public void run(){
       System.out.println("MyRunnable running");
    }
  }
```
此Runnable实现的全部作用是打印出文本 MyRunnable running。打印完该文本后，该run()方法退出，并且运行该run()方法的线程将停止。

#### Runnable的匿名实现
您还可以创建的匿名实现Runnable。这是实现Runnable接口的匿名Java类的示例：

```
Runnable myRunnable =
    new Runnable(){
        public void run(){
            System.out.println("Runnable running");
        }
    }
```
除了是一个匿名类之外，该示例与使用自定义类实现Runnable接口的示例非常相似。

#### Java Lambda可运行的实现
实现Runnable接口的第三种方法是通过创建接口的 Java Lambda实现Runnable。这是可能的，因为该Runnable接口仅具有单个未实现的方法，因此实际上（尽管可能是无意地）是 功能性Java接口。

这是实现Runnable接口的Java lambda表达式的示例：

```
Runnable runnable =
        () -> { System.out.println("Lambda Runnable running"); };
```

#### 用可运行的线程启动线程
要让该run()方法由线程执行，请在其构造函数中Runnable传递实现接口的类，匿名类或lambda表达式的实例Thread。这是完成的方式：

```
Runnable runnable = new MyRunnable(); // or an anonymous class, or lambda...

Thread thread = new Thread(runnable);
thread.start();
```
当线程启动时，它将调用 实例的run()方法，MyRunnable而不是执行其自己的run()方法。上面的示例将打印出文本“ MyRunnable running”。

### 使用哪种方式

对于这两种方法中哪一种最好没有任何规则。两种方法都有效。不过，就我个人而言，我更喜欢实现Runnable，并将实现的一个Thread实例交给一个实例。当Runnable由线程池执行时，很容易将Runnable 实例排队，直到池中的线程空闲为止。Thread子类很难做到这一点。

有时您可能必须实现Runnable子类Thread。例如，如果创建的子类Thread可以执行多个Runnable。实现线程池时通常是这种情况。

# 线程安全
可同时由多个线程安全调用的代码称为线程安全。如果一段代码是线程安全的，那么不会出现竞争的情况。

接下来要说明线程安全的相关概念

## 临界区
如果多个线程访问一个代码段，这些线程对代码段语句执行的顺序将影响最后的执行结果，那么这个代码段就叫做临界区（Critical Sections）。

当每个线程执行其内部代码的时候，其本身不会引起任何问题；引起问题的原因是对共享资源的使用。例如共用的内存（变量、数组和对象等）、系统资源（数据库、网络服务等）或者是文件。

跟进一步，事实上只有写共享资源操作才会引发问题。只要不进行修改，让多个线程读取相同的资源是安全的。

下面是一个临界区的 Java 代码示例
```
public class Counter {

    protected long count = 0;

    public void add(long value){
        this.count = this.count + value;
    }
}
```
例子中如果多个线程同时运行同一个Couner对象的add方法，产生的结果可能和预期值不符

现在假设两个线程 A 和 B 调用同一个Counter对象进行 add 操作，没有办法知道操作系统何时在两个线程间切换。 add()方法不是一步就可以执行完成的，而是按步骤执行的，代码会被细分为一系列更小的指令执行：

将 this.count 从内存中读到寄存器中
将 value 与寄存器中的数据相加并存入寄存器
将寄存器数据写入内存
那么现在考虑如下的线程 A 和 B 的执行情况：

this.count = 0;
B: 将 this.count 读入一个寄存器 (0) 
A: 将 this.count 读入一个寄存器 (0)
B: 将寄存器中的数据 +2 (2)
B: 将寄存器中的数据 (2) 写回内存，此时 this.count 等于 2
A: 将寄存器中的数据 +3 (3)
A: 将寄存器中的数据 (3) 写回内存，此时 this.count 等于 3
这两个线程的本来目的是将 2 和 3 加到 counter 上，所以期待的结果应该是 5。然而实际运行中线程发生了交错，导致结果与预期不同。上例中，两个线程都将 0 从内存中读出并且加上了 2 和 3，然后将其写回内存。所以最后的结果取决于谁最后将结果写回内存（2 和 3 都有可能）。

## 竞争
“竞争”是可能发生在“临界区”内的一种特使情况。如果临界区的执行结果受到多线程执行顺序的影响，那么就说存在竞争。竞争比喻了不同的线程互相争抢临界区的代码，并且争抢的结果也将影响临界区的运行结果。

前面例子的 add() 方法中存在着临界区，所以当多线程执行临界区代码的时候，就发生了竞争

## 共享资源
仅当多个线程更新共享资源时，才会出现争用条件。因此，为了保证线程安全，需要知道Java线程在执行时共享哪些资源

### 局部变量
局部变量存储在每个线程自己的堆栈中。这意味着局部变量永远不会在线程之间共享。这也意味着所有本地原始变量都是线程安全的。这是线程安全的本地原始变量的示例：
```
public void someMethod(){

  long threadSafeInt = 0;

  threadSafeInt++;
}
```
### 对象引用
对于线程内的对象引用变量是为共享的。但是，引用的对象并不是存储在每个线程的本地堆栈中。所有对象都存储在共享堆中。

如果线程内部创建的对象不会被其他线程引用，则该线程是安全的。

这是线程安全本地对象的示例：

```
public void someMethod(){

  LocalObject localObject = new LocalObject();

  localObject.callMethod();
  method2(localObject);
}

public void method2(LocalObject localObject){
  localObject.setValue("value");
}
```

LocalObject此示例中 的实例不是从方法返回的，也不会传递给可从someMethod()方法外部访问的任何其他对象。每个执行该someMethod()方法的线程都会创建自己的LocalObject 实例，并将其分配给localObject引用。因此，LocalObject此处的使用是线程安全的。

实际上，整个方法someMethod()都是线程安全的。即使将该 LocalObject实例作为参数传递给同一类或其他类中的其他方法，使用它也是线程安全的。

当然，唯一的例外是，如果使用LocalObjectas参数调用的方法之一以LocalObject 允许从其他线程访问它的方式存储实例。

### 对象成员变量
对象成员变量（字段）与对象一起存储在堆中。因此，如果两个线程在同一个对象实例上调用一个方法，并且此方法更新对象成员变量，则该方法不是线程安全的。这是一个不是线程安全的方法的示例：

```
public class NotThreadSafe{
    StringBuilder builder = new StringBuilder();

    public add(String text){
        this.builder.append(text);
    }
}
```
如果两个线程在同一个NotThreadSafe实例上add()同时调用该方法，则它将导致争用条件。例如：

```
NotThreadSafe sharedInstance = new NotThreadSafe();

new Thread(new MyRunnable(sharedInstance)).start();
new Thread(new MyRunnable(sharedInstance)).start();

public class MyRunnable implements Runnable{
  NotThreadSafe instance = null;

  public MyRunnable(NotThreadSafe instance){
    this.instance = instance;
  }

  public void run(){
    this.instance.add("some text");
  }
}
```
请注意，两个MyRunnable实例如何共享同一NotThreadSafe实例。因此，当他们add()在NotThreadSafe实例上调用该方法时，将导致争用条件。

但是，如果两个线程在不同实例上add()同时调用该方法 ，则不会导致争用条件。这是之前的示例，但稍作修改：

```
new Thread(new MyRunnable(new NotThreadSafe())).start();
new Thread(new MyRunnable(new NotThreadSafe())).start();
```
现在，两个线程各自具有自己的实例，NotThreadSafe因此它们对add方法的调用不会互相干扰。该代码不再具有竞争条件。因此，即使一个对象不是线程安全的，它仍然可以以不会导致竞争状态的方式使用。

## 不可变类
仅当多个线程正在访问同一资源并且一个或多个线程写入该资源时，才会发生争用条件。如果多个线程读取相同的资源 竞争条件，则不会发生。

通过使共享对象不可变，从而确保线程安全，可以确保线程之间共享的对象不会被任何线程更新。这是一个例子
```
public class ImmutableValue{

  private int value = 0;

  public ImmutableValue(int value){
    this.value = value;
  }

  public int getValue(){
    return this.value;
  }
}
```

注意ImmutableValue实例的值如何在构造函数中传递。还请注意，没有设置方法。一旦ImmutableValue实例被创建，你不能改变它的值。这是一成不变的。但是，您可以使用getValue()方法阅读它。

如果需要对ImmutableValue实例执行操作，可以通过返回一个新实例以及该操作产生的值来执行。这是添加操作的示例：
```
public class ImmutableValue{

  private int value = 0;

  public ImmutableValue(int value){
    this.value = value;
  }

  public int getValue(){
    return this.value;
  }

  
  public ImmutableValue add(int valueToAdd){
    return new ImmutableValue(this.value + valueToAdd);
  }
}
```
注意，该add()方法如何ImmutableValue使用添加操作的结果返回新实例，而不是将值添加到自身。

# 锁机制

为了实现线程安全，如果仅仅凭借定义不可变类或人为保证多线程不会出现竞争情况是不可能的，需要提供额外的机制来避免出现线程的竞争。java中引入锁机制来解决线程竞争的问题。多个线程运行到临界区代码时，只有获取到锁的线程可以继续执行，执行完临界区代码后将锁归还。其他线程在这段时间将等待直到自己获取到锁，才能执行临界区代码。

## 同步代码块

Java中可以将方法或代码块标记为同步。Java保证同一时刻只能有一个线程执行同步代码块中的代码，用于编写线程安全的代码。

### synchronized关键字

Java中的同步块用synchronized关键字标记。Java中的同步块在某些对象上同步。在同一个对象上同步的所有同步块只能在其中一个内部同时执行一个线程。尝试进入同步块的所有其他线程将被阻塞，直到同步块内的线程退出该块为止。

的synchronized关键字可以被用于标记四种不同类型的块：

* 实例方法
* 静态方法
* 实例方法中的代码块
* 静态方法中的代码块

这些块在不同的对象上同步。您需要哪种类型的同步块取决于具体情况。

### 同步实例方法

这是一个同步实例方法：

```
public synchronized void add(int value){
      this.count += value;
  }
```

注意synchronized方法声明中关键字的使用。这告诉Java该方法是同步的。

Java中的同步实例方法在拥有该方法的实例（对象）上同步。因此，每个实例在不同的对象（拥有实例）上具有同步的同步方法。在同步实例方法内部只能执行一个线程。如果存在多个实例，则每个实例一次可以在一个同步实例方法中执行一个线程。每个实例一个线程。

同步静态方法
静态方法被标记为已同步，就像使用synchronized关键字的实例方法一样 。这是一个Java同步静态方法示例：

```
public static synchronized void add(int value){
      count += value;
  }
```

同样，这里的synchronized关键字告诉Java方法是同步的。

同步静态方法在同步静态方法所属类的类对象上同步。由于每个类的Java VM中仅存在一个类对象，因此同一类中的静态同步方法中只能执行一个线程。

如果静态同步方法位于不同的类中，则一个线程可以在每个类的静态同步方法中执行。每个类一个线程，无论它调用哪种静态同步方法。

实例方法中的同步块
您不必同步整个方法。有时最好只同步方法的一部分。方法内部的Java同步块使这成为可能。

这是未同步的Java方法中的Java代码的同步块：

```
  public void add(int value){

    synchronized(this){
       this.count += value;   
    }
  }
```

本示例使用Java同步块构造将代码块标记为已同步。现在，该代码将像执行同步方法一样执行。

请注意，Java同步块构造如何在括号中使用对象。在示例“ this”中，使用了add方法。同步结构在括号中使用的对象称为监视对象。据说该代码已在监视对象上同步。同步实例方法将其所属的对象用作监视对象。

在同一监视对象上同步的Java代码块内只能执行一个线程。

以下两个示例都在调用它们的实例上同步。因此，它们在同步方面是等效的：


```
  public class MyClass {
  
    public synchronized void log1(String msg1, String msg2){
       log.writeln(msg1);
       log.writeln(msg2);
    }

  
    public void log2(String msg1, String msg2){
       synchronized(this){
          log.writeln(msg1);
          log.writeln(msg2);
       }
    }
  }
```

因此，在此示例中，只有一个线程可以在两个同步块中的任何一个内部执行。

如果第二个同步块已在与上不同的对象上同步this，则每次可以在每个方法中执行一个线程。

### 静态方法中的同步块

这是与静态方法相同的两个示例。这些方法在该方法所属的类的class对象上同步：

```
  public class MyClass {

    public static synchronized void log1(String msg1, String msg2){
       log.writeln(msg1);
       log.writeln(msg2);
    }

  
    public static void log2(String msg1, String msg2){
       synchronized(MyClass.class){
          log.writeln(msg1);
          log.writeln(msg2);  
       }
    }
  }
```

在这两个方法中的任何一个中只能同时执行一个线程。

如果第二个同步块已在之外的其他对象上同步MyClass.class，则一个线程可以在每个方法中同时执行。

### Java同步示例

这是一个示例，该示例启动2个线程，并让它们都在Counter的同一实例上调用add方法。一次仅一个线程将能够在同一实例上调用add方法，因为该方法在它所属的实例上是同步的。

```
  public class Counter{
     
     long count = 0;
    
     public synchronized void add(long value){
       this.count += value;
     }
  }
  public class CounterThread extends Thread{

     protected Counter counter = null;

     public CounterThread(Counter counter){
        this.counter = counter;
     }

     public void run() {
	for(int i=0; i<10; i++){
           counter.add(i);
        }
     }
  }
  public class Example {

    public static void main(String[] args){
      Counter counter = new Counter();
      Thread  threadA = new CounterThread(counter);
      Thread  threadB = new CounterThread(counter);

      threadA.start();
      threadB.start(); 
    }
  }
```

创建两个线程。相同的Counter实例将在其构造函数中传递给它们两个。该Counter.add()方法在实例上同步，因为add方法是实例方法，并标记为已同步。因此，只有一个线程可以一次调用add（）方法。另一个线程将等到第一个线程离开add（）方法之后才能执行该方法本身。

如果两个线程引用了两个单独的Counter实例，则同时调用add（）方法将没有问题。调用本来是对不同的对象的，所以调用的方法也将在不同的对象（拥有该方法的对象）上同步。因此，通话不会阻塞。看起来是这样的：

```
  public class Example {

    public static void main(String[] args){
      Counter counterA = new Counter();
      Counter counterB = new Counter();
      Thread  threadA = new CounterThread(counterA);
      Thread  threadB = new CounterThread(counterB);

      threadA.start();
      threadB.start(); 
    }
  }
```

请注意，线程A和线程B这两个线程不再引用相同的计数器实例。该add方法 counterA和counterB是在他们的两个拥有实例同步。因此，调用add()on counterA不会阻止对add() on 的调用counterB。

### synchronized缺点

该synchronized机制是Java的第一种用于同步访问多个线程共享的对象的机制。该synchronized机制不是很先进。这就是Java 5拥有一整套并发实用程序类 来帮助开发人员实现比您所获得的更细粒度的并发控制的原因synchronized。

在使用synchronized关键字的情形下，假如占有锁的线程由于要等待IO或者其他原因（比如调用sleep方法）被阻塞了，但是又没有释放锁，那么其他线程就只能一直等待，别无他法。这会极大影响程序执行效率。因此，就需要有一种机制可以不让等待的线程一直无期限地等待下去（比如只等待一定的时间 (解决方案：tryLock(long time, TimeUnit unit)) 或者 能够响应中断 (解决方案：lockInterruptibly())），这种情况可以通过 Lock 解决。

我们知道，当多个线程读写文件时，读操作和写操作会发生冲突现象，写操作和写操作也会发生冲突现象，但是读操作和读操作不会发生冲突现象。但是如果采用synchronized关键字实现同步的话，就会导致一个问题，即当多个线程都只是进行读操作时，也只有一个线程在可以进行读操作，其他线程只能等待锁的释放而无法进行读操作。因此，需要一种机制来使得当多个线程都只是进行读操作时，线程之间不会发生冲突。同样地，Lock也可以解决这种情况 (解决方案：ReentrantReadWriteLock) 。

我们可以通过Lock得知线程有没有成功获取到锁 (解决方案：ReentrantLock) ，但这个是synchronized无法办到的。

上面提到的三种情形，我们都可以通过Lock来解决，但 synchronized 关键字却无能为力。事实上，Lock 是 java.util.concurrent.locks包 下的接口，Lock 实现提供了比 synchronized 关键字 更广泛的锁操作，它能以更优雅的方式处理线程同步问题。也就是说，Lock提供了比synchronized更多的功能。但是要注意以下两点：

1）synchronized是Java的关键字，因此是Java的内置特性，是基于JVM层面实现的。而Lock是一个Java接口，是基于JDK层面实现的，通过这个接口可以实现同步访问；

2）采用synchronized方式不需要用户去手动释放锁，当synchronized方法或者synchronized代码块执行完之后，系统会自动让线程释放对锁的占用；而 Lock则必须要用户去手动释放锁，如果没有主动释放锁，就有可能导致死锁现象。





## 线程信号

为了完善synchronized功能，需要使用特性设计一套功能更强大的锁机制。要设计类似的机制，首先需要提供线程之间发送信号的能力。java提供了线程信令的机制使线程能够相互发送信号。另外，线程信令使线程能够等待来自其他线程的信号。例如，线程B可能会等待线程A发出的信号，表明数据已准备好进行处理。

### 通过共享对象发信号

线程互相发送信号的一种简单方法是在某些共享对象变量中设置信号值。线程A可以从同步块内部将布尔成员变量hasDataToProcess设置为true，线程B可以在同步块内部读取hasDataToProcess成员变量。这是一个对象的简单示例，该对象可以保存此类信号，并提供设置和检查该信号的方法：

```
public class MySignal{

  protected boolean hasDataToProcess = false;

  public synchronized boolean hasDataToProcess(){
    return this.hasDataToProcess;
  }

  public synchronized void setHasDataToProcess(boolean hasData){
    this.hasDataToProcess = hasData;  
  }

}
```

线程A和B必须具有对共享MySignal实例的引用，信令才能起作用。如果线程A和B引用了不同的MySignal实例，则它们将不会检测到彼此的信号。可以将要处理的数据放置在与MySignal实例分开的共享缓冲区中。

### 忙等待

要处理数据的线程B正在等待数据变得可用于处理。换句话说，它正在等待来自线程A的信号，该信号导致hasDataToProcess（）返回true。这是线程B在等待此信号时正在运行的循环：

```
protected MySignal sharedSignal = ...

...

while(!sharedSignal.hasDataToProcess()){
  //do nothing... busy waiting
}
```

注意while循环如何继续执行，直到hasDataToProcess（）返回true。这称为忙等待。等待时线程正忙。

### wait（），notify（）和notifyAll（）

繁忙等待不是运行等待线程的计算机中CPU的非常有效的利用率，除非平均等待时间很小。否则，如果等待线程在接收到正在等待的信号之前能够以某种方式休眠或变为非活动状态，那将变得更加明智。

Java具有内置的等待机制，该机制使线程在等待信号时变为非活动状态。java.lang.Object类定义了三种方法，wait（），notify（）和notifyAll（）来简化此过程。

在任何对象上调用wait（）的线程将变为非活动状态，直到另一个线程在该对象上调用notify（）为止。为了调用wait（）或通知，调用线程必须首先获取该对象的锁。换句话说，调用线程必须从同步块内部调用wait（）或notify（）。这是MySignal的修改版本，称为MyWaitNotify，它使用wait（）和notify（）。

```
public class MonitorObject{
}

public class MyWaitNotify{

  MonitorObject myMonitorObject = new MonitorObject();

  public void doWait(){
    synchronized(myMonitorObject){
      try{
        myMonitorObject.wait();
      } catch(InterruptedException e){...}
    }
  }

  public void doNotify(){
    synchronized(myMonitorObject){
      myMonitorObject.notify();
    }
  }
}
```

等待线程将调用doWait（），而通知线程将调用doNotify（）。当线程在对象上调用notify（）时，在该对象上等待的线程之一将被唤醒并允许执行。还有一个notifyAll（）方法，它将唤醒所有在给定对象上等待的线程。

如您所见，正在等待的线程和通知线程都从同步块内调用wait（）和notify（）。这是强制性的！线程不能在未保持调用该方法的对象上的锁的情况下调用wait（），notify（）或notifyAll（）。如果存在，则抛出IllegalMonitorStateException。

但是，这怎么可能呢？只要等待对象正在同步块中执行，等待线程就不会将其锁定在监视对象（myMonitorObject）上吗？等待线程是否不会阻塞通知线程，使其永远不会进入doNotify（）中的同步块？答案是不。线程调用wait（）后，它将释放它对监视对象持有的锁定。这允许其他线程也调用wait（）或notify（），因为必须从同步块内部调用这些方法。

线程唤醒后，它将无法退出wait（）调用，直到调用notify（）的线程离开其同步块为止。换句话说：唤醒的线程必须退出监视器对象才能退出wait（）调用，因为等待调用嵌套在一个同步块中。如果使用notifyAll（）唤醒多个线程，一次只有一个唤醒的线程可以退出wait（）方法，因为每个线程必须在退出wait（）之前依次获取监视对象的锁。

### 错过的信号

万一调用时没有线程在等待，方法notify（）和notifyAll（）不会将方法调用保存到它们中。然后，通知信号就丢失了。因此，如果线程在发出信号的线程调用wait（）之前调用notify（），则等待线程将丢失该信号。这可能是问题，也可能不是问题，但是在某些情况下，这可能会导致等待线程永远等待，永远不会醒来，因为错过了唤醒信号。

为避免丢失信号，应将其存储在信号类中。在MyWaitNotify示例中，通知信号应存储在MyWaitNotify实例内部的成员变量中。这是执行此操作的MyWaitNotify的修改版本：

```
public class MyWaitNotify2{

  MonitorObject myMonitorObject = new MonitorObject();
  boolean wasSignalled = false;

  public void doWait(){
    synchronized(myMonitorObject){
      if(!wasSignalled){
        try{
          myMonitorObject.wait();
         } catch(InterruptedException e){...}
      }
      //clear signal and continue running.
      wasSignalled = false;
    }
  }

  public void doNotify(){
    synchronized(myMonitorObject){
      wasSignalled = true;
      myMonitorObject.notify();
    }
  }
}
```

注意，在调用notify（）之前，doNotify（）方法现在如何将wasSignalled变量设置为true。另外，请注意doWait（）方法现在如何在调用wait（）之前检查wasSignalled变量。实际上，如果在先前的doWait（）调用与此调用之间未接收到任何信号，则仅调用wait（）。

### 虚假唤醒

出于无法解释的原因，即使未调用notify（）和notifyAll（），线程也可能会唤醒。这就是所谓的虚假唤醒。没有任何原因的唤醒。

如果MyWaitNofity2类的doWait（）方法中发生虚假唤醒，则等待线程可能会继续处理而未收到执行该操作的适当信号！这可能会在您的应用程序中引起严重的问题。

为了防止虚假唤醒，请在while循环内而不是if语句内检查signal成员变量。这样的while循环也称为自旋锁。唤醒的线程一直旋转，直到旋转锁（while循环）中的条件变为false为止。这是MyWaitNotify2的修改版本，显示了此内容：

```
public class MyWaitNotify3{

  MonitorObject myMonitorObject = new MonitorObject();
  boolean wasSignalled = false;

  public void doWait(){
    synchronized(myMonitorObject){
      while(!wasSignalled){
        try{
          myMonitorObject.wait();
         } catch(InterruptedException e){...}
      }
      //clear signal and continue running.
      wasSignalled = false;
    }
  }

  public void doNotify(){
    synchronized(myMonitorObject){
      wasSignalled = true;
      myMonitorObject.notify();
    }
  }
}
```

请注意，wait（）调用现在如何嵌套在while循环而不是if语句内。如果等待线程在没有收到信号的情况下唤醒，则wasSignalled成员仍然为false，并且while循环将再次执行，从而使唤醒的线程返回等待状态。

### 多线程等待相同的信号

如果您有多个等待的线程，而while循环也是一个不错的解决方案，这些线程都使用notifyAll（）唤醒了，但是只允许其中一个继续。一次只能有一个线程能够获得监视对象的锁定，这意味着只有一个线程可以退出wait（）调用并清除wasSignalled标志。一旦该线程退出doWait（）方法中的同步块，其他线程便可以退出wait（）调用并检查while循环内的wasSignalled成员变量。但是，第一个线程唤醒会清除此标志，因此其余唤醒的线程将返回等待状态，直到下一个信号到达为止。

### 不要在常量字符串或全局对象上调用wait（）

本文的早期版本具有MyWaitNotify示例类的版本，该示例类使用常量字符串（“”）作为监视对象。这是该示例的外观：

```
public class MyWaitNotify{

  String myMonitorObject = "";
  boolean wasSignalled = false;

  public void doWait(){
    synchronized(myMonitorObject){
      while(!wasSignalled){
        try{
          myMonitorObject.wait();
         } catch(InterruptedException e){...}
      }
      //clear signal and continue running.
      wasSignalled = false;
    }
  }

  public void doNotify(){
    synchronized(myMonitorObject){
      wasSignalled = true;
      myMonitorObject.notify();
    }
  }
}
```

在空字符串或任何其他常量字符串上调用wait（）和notify（）的问题是，JVM /编译器在内部将常量字符串转换为同一对象。这意味着，即使您有两个不同的MyWaitNotify实例，它们都引用相同的空字符串实例。这也意味着在第一个MyWaitNotify实例上调用doWait（）的线程可能会被在第二个MyWaitNotify实例上的doNotify（）调用唤醒。

下图概述了这种情况：

![在字符串常量上调用wait（）/ notify（）](http://tutorials.jenkov.com/images/java-concurrency/strings-wait-notify.png)



请记住，即使4个线程在同一个共享字符串实例上调用wait（）和notify（），来自doWait（）和doNotify（）调用的信号也分别存储在两个MyWaitNotify实例中。在MyWaitNotify 1上执行doNotify（）调用可能会唤醒在MyWaitNotify 2中等待的线程，但是该信号只会存储在MyWaitNotify 1中。

起初，这似乎不是一个大问题。毕竟，如果在第二个MyWaitNotify实例上调用doNotify（），那么真正发生的一切就是线程A和B被错误唤醒。唤醒的线程（A或B）将在while循环中检查其信号，然后返回等待状态，因为在第一个MyWaitNotify实例中未在其上等待调用doNotify（）。这种情况等同于引起虚假唤醒。线程A或B在未发出信号的情况下唤醒。但是代码可以处理此问题，因此线程可以返回等待状态。

问题在于，由于doNotify（）调用仅调用notify（）而不是notifyAll（），因此即使有4个线程在同一字符串实例（空字符串）上等待，也仅唤醒了一个线程。因此，如果实际上是针对C或D的信号唤醒了线程A或B中的一个，则唤醒的线程（A或B）将检查其信号，看到没有收到信号，然后返回等待状态。C或D都不会醒来以检查他们实际接收到的信号，因此会丢失该信号。这种情况等于前面所述的信号丢失问题。C和D发送了一个信号，但没有响应。

如果doNotify（）方法已调用notifyAll（）而不是notify（），则所有等待线程已被唤醒并依次检查信号。线程A和B将回到等待状态，但是C或D中的一个将注意到该信号并退出doWait（）方法调用。C和D中的另一个将返回等待状态，因为发现信号的线程会在退出doWait（）的过程中将其清除。

然后您可能很想总是调用notifyAll（）而不是notify（），但这在性能上是一个坏主意。当只有一个线程可以响应该信号时，没有理由唤醒所有正在等待的线程。

因此：不要将全局对象，字符串常量等用于wait（）/ notify（）机制。使用使用该构造唯一的对象。例如，每个MyWaitNotify3（前面部分中的示例）实例都有自己的MonitorObject实例，而不是将空字符串用于wait（）/ notify（）调用。

## 自定义锁

### 一个简单的锁

让我们开始看一下Java代码的同步块：

```
public class Counter{

  private int count = 0;

  public int inc(){
    synchronized(this){
      return ++count;
    }
  }
}
```

注意方法中的`synchronized(this)`块`inc()`。此块可确保一次只能执行一个线程`return ++count` 。同步块中的代码本来可以更高级，但简单的方法`++count`足以说明要点。

本`Counter`类也可以写成这样，使用`Lock`的而不是synchronized块：

```
public class Counter{

  private Lock lock = new Lock();
  private int count = 0;

  public int inc(){
    lock.lock();
    int newCount = ++count;
    lock.unlock();
    return newCount;
  }
}
```

该`lock()`方法锁定`Lock`实例，以便`lock()`阻止所有线程调用，直到`unlock()`执行为止。

这是一个简单的`Lock`实现：

```
public class Lock{

  private boolean isLocked = false;

  public synchronized void lock()
  throws InterruptedException{
    while(isLocked){
      wait();
    }
    isLocked = true;
  }

  public synchronized void unlock(){
    isLocked = false;
    notify();
  }
}
```

注意`while(isLocked)`循环，也称为“自旋锁”。自旋锁以及方法`wait()`和`notify()` ，当`isLocked`为true时，线程调用`lock()`将停在`wait()`调用中。如果线程应该在没有收到调用的情况下从wait（）调用中意外返回`notify()`（又名[Spurious Wakeup](http://tutorials.jenkov.com/java-concurrency/thread-signaling.html#spuriouswakeups)），则线程会重新检查`isLocked`条件以查看是否可以继续进行安全操作，而不仅仅是假设被唤醒意味着这是安全的。如果`isLocked`为false，则线程退出`while(isLocked)`循环，并设置`isLocked`回true，以锁定`Lock`其他线程调用的实例`lock()`。

当线程与在代码完成的[关键部分](http://tutorials.jenkov.com/java-concurrency/race-conditions-and-critical-sections.html) （之间的代码`lock()`和`unlock()`），线程调用`unlock()`。执行`unlock()`将设置`isLocked`返回false，并通知（唤醒）方法中等待`wait()`调用的线程之一（`lock()`如果有）。

### 重锁

Java中的同步块是可重入的。这意味着，如果Java线程输入了同步的代码块，从而锁定了同步该块的监视对象，则该线程可以输入在同一监视对象上同步的其他Java代码块。这是一个例子：

```
public class Reentrant{

  public synchronized outer(){
    inner();
  }

  public synchronized inner(){
    //do something
  }
}
```

请注意，`outer()`和`inner()`是如何声明为同步的，在Java中，这等效于一个`synchronized(this)`块。如果线程调用`outer()`，则从内部调用inner（）不会有问题 `outer()`，因为两个方法（或块）都在同一监视对象（“ this”）上同步。如果线程已经拥有监视对象上的锁，则它可以访问在同一监视对象上同步的所有块。这称为重入。线程可以重新输入已经为其持有锁的任何代码块。

前面显示的锁实现不是可重入的。如果我们`Reentrant` 像下面这样重写该类，则线程调用`outer()`将`lock.lock()`在`inner()`方法中被阻止 。

```
public class Reentrant2{

  Lock lock = new Lock();

  public outer(){
    lock.lock();
    inner();
    lock.unlock();
  }

  public synchronized inner(){
    lock.lock();
    //do something
    lock.unlock();
  }
}
```

线程调用`outer()`将首先锁定`Lock`实例。然后它将调用`inner()`。在`inner()`方法内部，线程将再次尝试锁定`Lock`实例。这将失败（意味着线程将被阻塞），因为`Lock`实例已在`outer()`方法中被锁定。

当我们看一下 实现时，显而易见的是 ，线程第二次调用`lock()`而在两次调用`unlock()`之间没有被阻塞的原因很明显`lock()`：

```
public class Lock{

  boolean isLocked = false;

  public synchronized void lock()
  throws InterruptedException{
    while(isLocked){
      wait();
    }
    isLocked = true;
  }

  ...
}
```

while循环（自旋锁）中的条件确定是否允许线程退出该`lock()`方法。目前的情况是，`isLocked` 必须`false`为这个被允许的，不管是什么的线程锁。

为了使`Lock`类可重入，我们需要做一些小改动：

```
public class Lock{

  boolean isLocked = false;
  Thread  lockedBy = null;
  int     lockedCount = 0;

  public synchronized void lock()
  throws InterruptedException{
    Thread callingThread = Thread.currentThread();
    while(isLocked && lockedBy != callingThread){
      wait();
    }
    isLocked = true;
    lockedCount++;
    lockedBy = callingThread;
  }


  public synchronized void unlock(){
    if(Thread.curentThread() == this.lockedBy){
      lockedCount--;

      if(lockedCount == 0){
        isLocked = false;
        notify();
      }
    }
  }

  ...
}
```

请注意，while循环（自旋锁）现在也将锁定`Lock` 实例的线程纳入考虑范围。如果锁被解锁（`isLocked`= false）或调用线程是锁定`Lock`实例的线程，则while循环将不会执行，并且`lock()`允许线程调用退出该方法。

此外，我们需要计算锁被同一线程锁定的次数。否则，`unlock()`即使该锁已被多次锁定，一次调用也会解锁该锁。我们不希望在锁定它的线程执行与`unlock()`调用相同数量的调用 之前将其解锁`lock()`。

该`Lock`班是现在折返。

### 锁公平

Java的同步块无法保证尝试进入线程的线程被授予访问权限的顺序。因此，如果许多线程一直在争夺对同一同步块的访问权，则存在一个或多个线程永远不会被授予访问权的风险-该访问权始终会授予其他线程。这称为饥饿。避免这种情况`Lock`应该公平。由于本文中`Lock`所示的实现在内部使用同步块，因此它们不能保证公平。饥饿和公平在“ [饥饿与公平”一书中](http://tutorials.jenkov.com/java-concurrency/starvation-and-fairness.html)进行了详细讨论 。

### 从最后一个子句中调用unlock（）

当用来保护关键部分时`Lock`，关键部分可能会引发异常，`unlock()`从`finally`-clause 内部调用该方法很重要。这样做确保将`Lock`解锁，以便其他线程可以锁定它。这是一个例子：

```
lock.lock();
try{
  //do critical section code, which may throw exception
} finally {
  lock.unlock();
}
```

这个小结构可以确保`Lock`在关键部分中的代码引发异常时将解锁。如果`unlock()` 未从`finally`-clause 内部调用，并且从关键部分引发了异常，则该异常`Lock`将永远锁定，从而导致`lock()`在该`Lock`实例上调用的所有线程都不确定地停止。

## 死锁

死锁是指两个或多个线程被阻塞，等待获得死锁中其他一些线程持有的锁。当多个线程同时需要相同的锁，但以不同的顺序获得它们时，就会发生死锁。

例如，如果线程1锁定A，然后尝试锁定B，并且线程2已经锁定B，然后尝试锁定A，则会出现死锁。线程1永远不会获得B，线程2永远不会获得A。此外，他们都不知道。他们将永远对每个对象A和B保持封锁。这种情况是一个僵局。

情况说明如下：

```
线程1锁定A，等待B
线程2锁定B，等待A
```

这是一个TreeNode类的示例，该类在不同的实例中调用同步方法：

```
公共类TreeNode {
 
  TreeNode parent = null;  
  列出子项= new ArrayList（）;

  公共同步void addChild（TreeNode child）{
    if（！this.children.contains（child））{
      this.children.add（child）;
      child.setParentOnly（this）;
    }
  }
  
  公共同步void addChildOnly（TreeNode child）{
    if（！this.children.contains（child）{
      this.children.add（child）;
    }
  }
  
  公共同步void setParent（TreeNode父级）{
    this.parent =父级；
    parent.addChildOnly（this）;
  }

  公共同步void setParentOnly（TreeNode父级）{
    this.parent =父级；
  }
}
```

如果在相同的父实例和子实例上，线程（1）同时调用parent.addChild（child）方法而另一个线程（2）调用child.setParent（parent）方法，则可能会发生死锁。以下是一些伪代码说明了这一点：



```
线程1：parent.addChild（child）; //锁定父项
          -> child.setParentOnly（parent）;

线程2：child.setParent（parent）; //锁定孩子
          -> parent.addChildOnly（）
```

第一个线程1调用parent.addChild（child）。由于addChild（）是同步线程，因此线程1有效地锁定了父对象以供其他踩踏访问。

然后线程2调用child.setParent（parent）。由于setParent（）是同步的，线程2有效地锁定了子对象以防止其他线程访问。

现在，子对象和父对象都被两个不同的线程锁定。下一个线程1尝试调用child.setParentOnly（）方法，但是子对象被线程2锁定，因此该方法调用只是阻塞。线程2还尝试调用parent.addChildOnly（），但父对象被线程1锁定，导致线程2在该方法调用上阻塞。现在，两个线程都被阻塞，等待获取另一个线程持有的锁。

注意：这两个线程必须如上所述同时在相同的两个父实例和子实例上同时调用parent.addChild（child）和child.setParent（parent）才能发生死锁。上面的代码可能会执行很长时间，直到突然陷入僵局。

线程确实需要“同时”获取锁。例如，如果线程1领先于线程2，因此同时锁定了A和B，那么在尝试锁定B时线程2将已经被阻塞。这样就不会发生死锁。由于线程调度通常是不可预测的，因此无法预测何时发生死锁。只有它可以发生。

### 更复杂的死锁

死锁也可以包括两个以上的线程。这使得更难检测。这是四个线程陷入僵局的示例：

```
线程1锁定A，等待B
线程2锁定B，等待C
线程3锁定C，等待D
线程4锁定D，等待A
```

线程1等待线程2，线程2等待线程3，线程3等待线程4，线程4等待线程1。

### 防止死锁

#### 锁顺序

当多个线程需要相同的锁但以不同的顺序获得它们时，就会发生死锁。

如果您确保所有线程始终按相同顺序获取所有锁，则不会发生死锁。看这个例子：

```
线程1：

  锁A 
  锁B


线程2：

   等待A
   锁C（当A锁定时）


线程3：

   等待A
   等待B
   等待C
```

如果一个线程（如线程3）需要多个锁，则必须按确定的顺序进行操作。在获得较早的锁定之前，它无法在序列的后面获得锁定。

例如，线程2或线程3都不能锁定C，直到它们首先锁定A。由于线程1持有锁A，因此线程2和3必须首先等待直到锁A解锁。然后，他们必须成功锁定A，然后才能尝试锁定B或C。

锁排序是一种简单而有效的防止死锁机制。但是，仅当您在获取任何锁之前了解所需的所有锁时，才可以使用它。这并非总是如此。



#### 锁定超时

另一个防止死锁的机制是对锁定尝试进行超时，这意味着试图获得锁定的线程只会尝试放弃这么长时间。如果线程在给定的超时时间内未成功获取所有必要的锁，它将备份，释放所有已获取的锁，等待随机的时间，然后重试。等待的随机时间使尝试采用相同锁的其他线程有机会获得所有锁，从而使应用程序继续运行而没有锁定。

这是两个线程尝试以不同顺序获取相同的两个锁的示例，其中线程备份并重试：

```
线程1锁A
线程2锁B

线程1尝试锁定B但被阻止
线程2尝试锁定A但被阻止

线程1对B的锁定尝试超时
线程1备份并释放A
线程1在重试之前随机等待（例如257毫秒）。

线程2的A锁定尝试超时
线程2备份并释放B
线程2随机等待（例如43毫秒），然后重试。
```

在上面的示例中，线程2将在线程1之前重试大约200毫秒的锁，因此很可能会成功获得两个锁。然后，线程1将等待已经尝试获取锁A的线程。当线程2完成时，线程1也将同时获取两个锁（除非线程2或另一个线程在两者之间获取锁）。

要记住的一个问题是，仅由于锁定超时并不一定意味着线程已死锁。这也可能仅意味着持有锁的线程（导致另一个线程超时）需要很长时间才能完成其任务。

此外，如果有足够的线程争用相同的资源，即使超时和备份，它们仍然有冒险尝试一次又一次地占用线程。在重试之前，有2个线程在0到500毫秒之间等待，可能不会发生这种情况，但是有10或20个线程时情况就不同了。然后，两个线程在重试之前（或者足够接近以引起问题）同时等待的可能性要高得多。

锁定超时机制的问题在于，无法为Java中的同步块设置超时设置。您将必须创建一个自定义锁类或使用java.util.concurrency包中的Java 5并发构造之一。编写自定义锁并不困难，但这超出了本文的范围。Java并发跟踪中的后续文本将涵盖自定义锁。



#### 死锁检测

死锁检测是一种较重的防止死锁的机制，用于无法进行锁排序和锁超时不可行的情况。

每当一个线程**需要**它在线程和锁的数据结构（图，图表等）指出的锁。此外，每当线程**请求**锁定时，此数据结构中也会对此进行记录。

当线程请求锁定但请求被拒绝时，线程可以遍历锁定图以检查死锁。例如，如果线程A请求锁7，但锁7由线程B持有，则线程A可以检查线程B是否请求了线程A持有的任何锁（如果有）。如果线程B发出请求，则发生死锁（线程A取得了锁1，请求了锁7，线程B取得了锁7，请求了锁1）。

当然，死锁方案可能比两个互相持有锁的线程要复杂得多。线程A可能等待线程B，线程B等待线程C，线程C等待线程D，线程D等待线程A。为了使线程A检测到死锁，它必须可传递地检查线程B所请求的所有锁。从线程B请求的锁中，线程A将到达线程C，然后到达线程D，线程D从中找到线程A本身持有的一个锁。然后，它知道发生了死锁。

以下是4个线程（A，B，C和D）获取和请求的锁的图表。这样的数据结构可用于检测死锁。





![死锁检测数据结构](http://tutorials.jenkov.com/images/java-concurrency/deadlock-detection-graph.png)





那么，如果检测到死锁，线程该怎么办？

一种可能的操作是释放所有锁，备份，等待随机的时间然后重试。这类似于更简单的锁定超时机制，除了线程仅在实际发生死锁时才进行备份。不仅仅是因为他们的锁定请求超时。但是，如果许多线程在争夺相同的锁，则即使它们备份并等待，它们也可能反复陷入死锁。

更好的选择是确定或分配线程的优先级，以便仅备份一个（或几个）线程。其余线程继续获取所需的锁，就好像没有发生死锁一样。如果分配给线程的优先级是固定的，则相同的线程将始终被赋予更高的优先级。为避免这种情况，您可以在检测到死锁时随机分配优先级。


# 停止线程
## 暂停线程
线程可以通过调用static方法来暂停自身Thread.sleep()。在sleep() 需要数毫秒作为参数。该sleep()方法将尝试在恢复执行之前休眠该毫秒数。线程sleep()不是100％精确的，但还是很不错的。这是通过调用Thread sleep()方法将Java线程暂停3秒（3.000毫秒）的示例：

```
try {
    Thread.sleep(10L * 1000L);
} catch (InterruptedException e) {
    e.printStackTrace();
}
```
执行上述Java代码的线程将休眠大约10秒钟（10.000毫秒）。

## 停止线程
停止Java线程需要一些线程实现代码的准备。Java Thread类包含一个stop()方法，但已弃用。原始stop() 方法无法保证线程在什么状态下停止。这意味着，线程在执行过程中可以访问的所有Java对象将处于未知状态。如果您的应用程序中的其他线程也可以访问相同的对象，则您的应用程序可能会意外失败并且无法预期。

不该stop()方法，必须手动实现停止该线程的代码。这是一个实现的类示例，Runnable其中包含一个称为的额外方法doStop()，该方法 向Runnable发出停止信号。该Runnable会检查这个信号，并停止当它准备这样做。

```
public class MyRunnable implements Runnable {

    private boolean doStop = false;

    public synchronized void doStop() {
        this.doStop = true;
    }

    private synchronized boolean keepRunning() {
        return this.doStop == false;
    }

    @Override
    public void run() {
        while(keepRunning()) {
            // keep doing what this thread should do.
            System.out.println("Running");

            try {
                Thread.sleep(3L * 1000L);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

        }
    }
}
```
注意doStop()和keepRunning()方法。在doStop()旨在被从另一个线程小于线程执行被调用MyRunnable的run() 方法。该keepRunning()方法由执行MyRunnable的run()方法的线程在内部调用 。只要doStop()尚未调用，该keepRunning()方法就会返回true-意味着执行该run()方法的线程 将继续运行。

这是一个启动Java线程的示例，该线程执行上述MyRunnable 类的实例，并在延迟后再次停止它：

```
public class MyRunnableMain {

    public static void main(String[] args) {
        MyRunnable myRunnable = new MyRunnable();

        Thread thread = new Thread(myRunnable);

        thread.start();

        try {
            Thread.sleep(10L * 1000L);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        myRunnable.doStop();
    }
}
```
本示例首先创建一个MyRunnable实例，然后将该实例传递给线程并启动该线程。然后执行该main()方法的线程（主线程）休眠10秒钟，然后调用实例的doStop()方法MyRunnable。这将导致执行该MyRunnable方法的线程停止，因为keepRunning()将true在after之后返回doStop()。

请记住，如果您的Runnable实现不仅需要 run()方法（例如a stop()或pause()方法），那么您将无法再Runnable使用Java lambda表达式创建实现。Java lambda只能实现一个方法。取而代之的是，您必须使用自定义类或扩展的自定义接口，该类 Runnable具有额外的方法，并且由匿名类实现。



# 线程管理

## java.util.concurrency

### BlockingQueue

在*Java的* *的BlockingQueue*接口，`java.util.concurrent.BlockingQueue`代表队列是线程安全的把元素融入，并采取了元素从。换句话说，多个线程可以从Java同时插入和获取元素`BlockingQueue`，而不会出现任何并发问题。

术语“ *阻塞* *队列”*源自Java `BlockingQueue`能够阻塞试图从队列中插入或获取元素的线程的事实。例如，如果线程尝试采用元素，而队列中没有剩余元素，则可以阻塞线程，直到有元素要采用为止。调用线程是否被阻塞取决于您在上调用了哪些方法`BlockingQueue`。稍后将详细说明不同的方法。

本文不会讨论如何`BlockingQueue`自己用Java 实现。如果您对此感兴趣，请在我的理论性更高的[Java并发教程中找到](http://tutorials.jenkov.com/java-concurrency/index.html)有关[阻塞队列的内容](http://tutorials.jenkov.com/java-concurrency/blocking-queues.html)。



#### BlockingQueue的使用

甲`BlockingQueue`通常用于具有一个线程产生对象，另一个线程消耗。这是说明此原理的图：

| ![一个BlockingQueue，其中一个线程放入其中，另一个线程从中取出。](http://tutorials.jenkov.com/images/java-concurrency-utils/blocking-queue.png) |
| ------------------------------------------------------------ |
| **一个BlockingQueue，其中一个线程放入其中，另一个线程从中取出。** |

生产线程将继续生产新对象并将其插入`BlockingQueue`，直到队列达到其所包含内容的上限。换句话说，这是极限。如果阻塞队列达到其上限，则在尝试插入新对象时会阻塞生产线程。它一直保持阻塞状态，直到使用线程将对象从队列中取出。

消耗线程不断`BlockingQueue`从中取出对象进行处理。如果使用方线程尝试将对象从空队列中取出，则使用方线程将被阻塞，直到产生方线程将对象放入队列中为止。



#### BlockingQueue方法

Java `BlockingQueue`接口具有4种不同的方法集，用于插入，删除和检查队列中的元素。如果无法立即执行所请求的操作，则每种方法的行为都会有所不同。这是方法表：

|          | **引发异常** | **特殊价值** | **积木** | **超时**                      |
| -------- | ------------ | ------------ | -------- | ----------------------------- |
| **插入** | `add(o)`     | `offer(o)`   | `put(o)` | `offer(o, timeout, timeunit)` |
| **去掉** | `remove(o)`  | `poll()`     | `take()` | `poll(timeout, timeunit)`     |
| **检查** | `element()`  | `peek()`     | ` `      | ` `                           |

这4种不同的行为集意味着：

1. **引发异常**：
   如果无法立即进行尝试的操作，则引发异常。
2. **特殊值**：
   如果无法立即尝试操作，则会返回一个特殊值（通常为true / false）。
3. **块**：
   如果无法立即进行尝试的操作，则该方法调用将一直阻塞直到可行为止。
4. **超时**：
   如果无法立即进行尝试的操作，则该方法调用将一直阻塞直到成功，但等待时间不得长于给定的超时。返回一个告诉操作是否成功的特殊值（通常为true / false）。

这是不可能插入`null`到`BlockingQueue`。如果您尝试插入null， `BlockingQueue`则将抛出`NullPointerException`。

还可以访问a内的所有元素`BlockingQueue`，而不仅是开始和结束处的元素。例如，假设您已将一个对象排队等待处理，但是您的应用程序决定取消该对象。然后，您可以调用例如`remove(o)`删除队列中的特定对象。但是，这样做的效率不是很高，因此`Collection`除非确实需要，否则不应使用这些方法。



#### BlockingQueue实现

由于`BlockingQueue`是一个接口，因此您需要使用其实现之一来使用它。该`java.util.concurrent`软件包具有以下`BlockingQueue` 接口实现：

- [ArrayBlockingQueue](http://tutorials.jenkov.com/java-util-concurrent/arrayblockingqueue.html)
- [延迟队列](http://tutorials.jenkov.com/java-util-concurrent/delayqueue.html)
- [LinkedBlockingQueue](http://tutorials.jenkov.com/java-util-concurrent/linkedblockingqueue.html)
- [PriorityBlockingQueue](http://tutorials.jenkov.com/java-util-concurrent/priorityblockingqueue.html)
- [同步队列](http://tutorials.jenkov.com/java-util-concurrent/synchronousqueue.html)

单击列表中的链接以了解有关每个实现的更多信息。



#### Java BlockingQueue示例

这是一个Java `BlockingQueue`示例。该示例使用接口的`ArrayBlockingQueue` 实现`BlockingQueue`。

首先， 在单独的线程中`BlockingQueueExample`启动a `Producer`和a 的类`Consumer`。所述`Producer`插入件的字符串到共享`BlockingQueue`，并且`Consumer`需要他们。

```
public class BlockingQueueExample {

    public static void main(String[] args) throws Exception {

        BlockingQueue queue = new ArrayBlockingQueue(1024);

        Producer producer = new Producer(queue);
        Consumer consumer = new Consumer(queue);

        new Thread(producer).start();
        new Thread(consumer).start();

        Thread.sleep(4000);
    }
}
```

这是`Producer`课程。注意每个`put()`呼叫之间的睡眠时间。`Consumer`等待队列中的对象时，这将导致阻塞。

```
public class Producer implements Runnable{

    protected BlockingQueue queue = null;

    public Producer(BlockingQueue queue) {
        this.queue = queue;
    }

    public void run() {
        try {
            queue.put("1");
            Thread.sleep(1000);
            queue.put("2");
            Thread.sleep(1000);
            queue.put("3");
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

这是`Consumer`课程。它只是从队列中取出对象，然后将它们打印到`System.out`。

```java
public class Consumer implements Runnable{

    protected BlockingQueue queue = null;

    public Consumer(BlockingQueue queue) {
        this.queue = queue;
    }

    public void run() {
        try {
            System.out.println(queue.take());
            System.out.println(queue.take());
            System.out.println(queue.take());
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

### CountDownLatch

A `java.util.concurrent.CountDownLatch`是一种并发构造，它允许一个或多个线程等待一组给定的操作完成。

`CountDownLatch`用给定的计数初始化 A。通过调用该`countDown()`方法可以减少此计数 。等待该计数达到零的线程可以调用`await()` 方法之一。调用将`await()`阻塞线程，直到计数达到零为止。

下面是一个简单的示例。在`Decrementer`上呼叫了`countDown()`3次后 `CountDownLatch`，等待`Waiter`的`await()`呼叫即被释放。

```
CountDownLatch latch = new CountDownLatch(3);

Waiter      waiter      = new Waiter(latch);
Decrementer decrementer = new Decrementer(latch);

new Thread(waiter)     .start();
new Thread(decrementer).start();

Thread.sleep(4000);
public class Waiter implements Runnable{

    CountDownLatch latch = null;

    public Waiter(CountDownLatch latch) {
        this.latch = latch;
    }

    public void run() {
        try {
            latch.await();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("Waiter Released");
    }
}
public class Decrementer implements Runnable {

    CountDownLatch latch = null;

    public Decrementer(CountDownLatch latch) {
        this.latch = latch;
    }

    public void run() {

        try {
            Thread.sleep(1000);
            this.latch.countDown();

            Thread.sleep(1000);
            this.latch.countDown();

            Thread.sleep(1000);
            this.latch.countDown();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

### CyclicBarrier

所述`java.util.concurrent.CyclicBarrier`类是同步机构，其能够同步线程通过某种算法推进。换句话说，这是所有线程必须继续等待直到所有线程到达它的障碍。这是说明此的图：

| ![两个线程在CyclicBarriers中互相等待。](http://tutorials.jenkov.com/images/java-concurrency-utils/cyclic-barrier.png) |
| ------------------------------------------------------------ |
| **两个线程在CyclicBarriers中互相等待。**                     |

线程通过调用上的`await()`方法互相等待`CyclicBarrier`。一旦N个线程在处等待`CyclicBarrier`，所有线程将被释放并可以继续运行。



#### 创建一个CyclicBarrier

创建a时，`CyclicBarrier`您指定释放它们之前要等待多少个线程。这是创建方式的方法`CyclicBarrier`：

```
CyclicBarrier barrier =新的CyclicBarrier（2）;
```



#### 在CyclicBarrier中等待

这是线程在处等待的方式`CyclicBarrier`：

```
barrier.await（）;
```

您还可以为等待的线程指定超时。超时后，即使不是所有的N个线程都在处等待，该线程也会被释放`CyclicBarrier`。这是您指定超时的方法：

```
barrier.await（10，TimeUnit.SECONDS）;
```

等待线程等待`CyclicBarrier`直到：

- 最后一个线程到达（调用await（））
- 该线程被另一个线程中断（另一个线程调用其interrupt（）方法）
- 另一个等待线程被中断
- 在等待时，另一个等待线程超时 `CyclicBarrier`
- 该`CyclicBarrier.reset()`方法由某些外部线程调用。



#### 循环屏障动作

该`CyclicBarrier`支持屏障作用，这是一个`Runnable`曾经的最后一个线程到达时执行。您将`Runnable`屏障操作传递给`CyclicBarrier` 其构造函数中的，如下所示：

```
可运行的barrierAction = ...;
CyclicBarrier barrier =新的CyclicBarrier（2，barrierAction）;
```



#### CyclicBarrier示例

这是一个代码示例，向您展示如何使用`CyclicBarrier`：

```
Runnable barrier1Action = new Runnable（）{
    公共无效run（）{
        System.out.println（“执行BarrierAction 1”）;
    }
};
Runnable barrier2Action = new Runnable（）{
    公共无效run（）{
        System.out.println（“执行BarrierAction 2”）;
    }
};

CyclicBarrier barrier1 =新的CyclicBarrier（2，barrier1Action）;
CyclicBarrier barrier2 =新的CyclicBarrier（2，barrier2Action）;

CyclicBarrierRunnable barrierRunnable1 =
        新的CyclicBarrierRunnable（barrier1，barrier2）;

CyclicBarrierRunnable barrierRunnable2 =
        新的CyclicBarrierRunnable（barrier1，barrier2）;

新线程（barrierRunnable1）.start（）;
新线程（barrierRunnable2）.start（）;
```

这是`CyclicBarrierRunnable`课程：

```
公共类CyclicBarrierRunnable实现Runnable {

    CyclicBarrier barrier1 = null;
    CyclicBarrier barrier2 = null;

    公共CyclicBarrierRunnable（
            CyclicBarrier barrier1，
            CyclicBarrier barrier2）{

        this.barrier1 = barrier1;
        this.barrier2 = barrier2;
    }

    公共无效run（）{
        尝试{
            Thread.sleep（1000）;
            System.out.println（Thread.currentThread（）。getName（）+
                                “在障碍1处等待”）；
            this.barrier1.await（）;

            Thread.sleep（1000）;
            System.out.println（Thread.currentThread（）。getName（）+
                                “在障碍2处等待”）；
            this.barrier2.await（）;

            System.out.println（Thread.currentThread（）。getName（）+
                                “完成！”）;

        } catch（InterruptedException e）{
            e.printStackTrace（）;
        } catch（BrokenBarrierException e）{
            e.printStackTrace（）;
        }
    }
}
```

这是执行上述代码的控制台输出。请注意，线程执行写入控制台的顺序可能因执行而异。有时 `Thread-0`先打印，有时`Thread-1`先打印等。

```
线程-0在障碍1处等待
线程1在障碍1处等待
执行BarrierAction 1
线程1等待障碍2
线程-0等待障碍2
执行BarrierAction 2
线程-0完成！
线程1完成！
```





### ExecutorService

Java *ExecutorService*接口`java.util.concurrent.ExecutorService`表示一种异步执行机制，该机制能够在后台同时执行任务。在本Java `ExecutorService`教程中，我将说明如何创建`ExecutorService`，如何提交要执行的任务，如何查看这些任务的结果以及`ExecutorService`在需要时如何再次关闭 。



#### 任务委托

以下是说明线程的示例，该线程将任务委派给Java `ExecutorService`以进行异步执行：

| ![一个将任务委派给ExecutorService以便异步执行的线程。](http://tutorials.jenkov.com/images/java-concurrency-utils/executor-service.png) |
| ------------------------------------------------------------ |
| **一个将任务委派给ExecutorService以便异步执行的线程。**      |

线程将任务委派给后`ExecutorService`，线程将继续自己的执行，而与该任务的执行无关。在`ExecutorService`随后同时执行独立提交任务的线程的任务。



#### Java ExecutorService示例

在不深入了解之前`ExecutorService`，让我们看一个简单的示例。这是一个简单的Java `ExecutorService`示例：

```
ExecutorService executorService = Executors.newFixedThreadPool（10）;

executorService.execute（new Runnable（）{
    公共无效run（）{
        System.out.println（“异步任务”）;
    }
}）;

executorService.shutdown（）;
```

首先`ExecutorService`使用`Executors` `newFixedThreadPool()` 工厂方法创建一个。这将创建一个具有10个执行任务的线程的线程池。

第二，将`Runnable`接口的匿名实现传递给该`execute()`方法。这使得`Runnable`可以由中的线程之一执行`ExecutorService`。

您将`ExecutorService`在本教程中看到更多有关如何使用本教程的示例。这个例子只是用来让您快速了解如何`ExecutorService`在后台执行任务。



#### Java ExecutorService实现

Java `ExecutorService`非常类似于[线程池](http://tutorials.jenkov.com/java-concurrency/thread-pools.html)。实际上，包中`ExecutorService`存在的接口 的实现`java.util.concurrent`是线程池实现。如果您想了解如何在`ExecutorService`内部实现该 接口，请阅读上面的教程。

由于`ExecutorService`是一个接口，因此您需要对其实施以进行任何使用。本`ExecutorService`已在以下实现`java.util.concurrent` 包：

- [线程池执行器](http://tutorials.jenkov.com/java-util-concurrent/threadpoolexecutor.html)
- [ScheduledThreadPoolExecutor](http://tutorials.jenkov.com/java-util-concurrent/scheduledexecutorservice.html)



#### 创建一个ExecutorService

如何创建一个`ExecutorService`取决于您使用的实现。但是，您也可以使用`Executors`factory类创建`ExecutorService`实例。以下是创建的一些示例`ExecutorService`：

```
ExecutorService executorService1 = Executors.newSingleThreadExecutor（）;

ExecutorService executorService2 = Executors.newFixedThreadPool（10）;

ExecutorService executorService3 = Executors.newScheduledThreadPool（10）;
```



#### ExecutorService的用法

有几种不同的方式将执行任务委派给`ExecutorService`：

- 执行（可运行）
- 提交（可运行）
- 提交（可调用）
- invokeAny（...）
- invokeAll（...）

在以下各节中，我将介绍每种方法。



##### 执行可运行

Java `ExecutorService` `execute(Runnable)`方法采用一个`java.lang.Runnable`对象，并异步执行它。这里是执行的一个例子`Runnable`具有`ExecutorService`：

```
ExecutorService executorService = Executors.newSingleThreadExecutor（）;

executorService.execute（new Runnable（）{
    公共无效run（）{
        System.out.println（“异步任务”）;
    }
}）;

executorService.shutdown（）;
```

`Runnable`如有必要， 无法获得执行结果。您将为此使用a `Callable`（在以下各节中说明）。



##### 提交可运行

Java `ExecutorService` `submit(Runnable)`方法也采用一个`Runnable`实现，但是返回一个`Future`对象。该`Future`对象可用于检查是否`Runnable` 已完成执行。

这是一个Java `ExecutorService` `submit()`示例：

```
未来的未来= executorService.submit（new Runnable（）{
    公共无效run（）{
        System.out.println（“异步任务”）;
    }
}）;

future.get（）; //如果任务正确完成，则返回null。
```

该`submit()`方法返回[Java Future](http://tutorials.jenkov.com/java-util-concurrent/java-future.html)对象，该对象可用于检查[Java](http://tutorials.jenkov.com/java-util-concurrent/java-future.html)对象何时`Runnable`完成。



##### 提交可致电

Java `ExecutorService` `submit(Callable)`方法与方法类似，`submit(Runnable)` 不同之处在于它使用[Java Callable](http://tutorials.jenkov.com/java-util-concurrent/java-callable.html)而不是[Java](http://tutorials.jenkov.com/java-util-concurrent/java-callable.html)`Runnable`。a `Callable`和a 之间的精确差异将在`Runnable`稍后说明。

所述`Callable`的结果可以通过获得[的Java未来](http://tutorials.jenkov.com/java-util-concurrent/java-future.html)由返回的对象 `submit(Callable)`的方法。这是一个`ExecutorService` `Callable`例子：

```
未来的未来= executorService.submit（new Callable（）{
    公共对象call（）引发异常{
        System.out.println（“异步可调用”）;
        返回“可调用结果”；
    }
}）;

System.out.println（“ future.get（）=” + future.get（））;
```

上面的代码示例将输出以下内容：

```
异步可调用
future.get（）=可调用的结果
```



##### invokeAny（）

该`invokeAny()`方法采用`Callable`对象或的子接口的集合`Callable`。调用此方法不会返回`Future`，而是返回`Callable`对象之一的结果。您无法保证`Callable`获得的结果。只是其中之一。

如果其中一项任务完成（或引发异常），则其余的将`Callable`被取消。

这是一个代码示例：

```
ExecutorService executorService = Executors.newSingleThreadExecutor（）;

Set <Callable <String >>可调用对象= new HashSet <Callable <String >>（）;

callables.add（new Callable <String>（）{
    公共字符串call（）引发异常{
        返回“任务1”；
    }
}）;
callables.add（new Callable <String>（）{
    公共字符串call（）引发异常{
        返回“任务2”；
    }
}）;
callables.add（new Callable <String>（）{
    公共字符串call（）引发异常{
        返回“任务3”；
    }
}）;

字符串结果= executorService.invokeAny（callables）;

System.out.println（“ result =” + result）;

executorService.shutdown（）;
```

此代码示例将打印出`Callable`给定collection中的之一返回的对象。我试过几次，结果改变了。有时是“任务1”，有时是“任务2”等。



##### invokeAll（）

该`invokeAll()`方法调用`Callable`作为参数传递的集合中传递给它的所有对象。在`invokeAll()`返回的列表`Future` 对象通过它您可以获取每个执行的结果`Callable`。

请记住，任务可能由于异常而完成，因此它可能没有“成功”。尚无办法`Future`分辨出差异。

这是一个代码示例：

```
ExecutorService executorService = Executors.newSingleThreadExecutor（）;

Set <Callable <String >>可调用对象= new HashSet <Callable <String >>（）;

callables.add（new Callable <String>（）{
    公共字符串call（）引发异常{
        返回“任务1”；
    }
}）;
callables.add（new Callable <String>（）{
    公共字符串call（）引发异常{
        返回“任务2”；
    }
}）;
callables.add（new Callable <String>（）{
    公共字符串call（）引发异常{
        返回“任务3”；
    }
}）;

List <Future <String >>期货= executorService.invokeAll（callables）;

for（Future <String> future：futures）{
    System.out.println（“ future.get =” + future.get（））;
}

executorService.shutdown（）;
```



##### 可运行与可调用

该`Runnable`界面与该界面非常相似`Callable`。这两个接口都表示可以由线程或并发执行的任务`ExecutorService`。这两个接口只有一个方法。`Callable` 和`Runnable`接口之间有一个小的区别。当您看到接口声明时，`Runnable`and `Callable`接口之间的区别更容易看到。

首先是`Runnable`接口声明：

```
公用接口Runnable {
    public void run（）;
}
```

这是`Callable`接口声明：

```
公用接口可调用{
    public Object call（）抛出异常；
}
```

`Runnable` `run()`方法和 `Callable` `call()`方法 之间的主要区别是`call()`方法可以`Object`从方法调用中返回。`call()`和 之间的另一个区别`run()`是`call()`可以引发异常，而不能引发异常`run()` （未经检查的异常-的子类除外`RuntimeException`）。

如果您需要向Java提交任务，`ExecutorService`并且需要任务的结果，则需要使您的任务实现该`Callable`接口。否则，您的任务只能实现`Runnable`接口。



##### 取消任务

您可以 通过在提交任务时调用返回的方法来取消提交给Java 的任务（`Runnable`或`Callable`）。仅当任务尚未开始执行时才可以取消任务。这是通过调用方法取消任务的示例： `ExecutorService``cancel()``Future``Future.cancel()`

```
future.cancel（）;
```



#### 执行器服务关闭

使用完Java之后`ExecutorService`，应将其关闭，这样线程就不会继续运行。如果您的应用程序是通过某种`main()`方法启动的，并且主线程退出了您的应用程序，那么如果您`ExexutorService`的应用程序中有活动的应用程序，它将继续运行。其中的活动线程`ExecutorService` 可防止JVM关闭。



##### 关掉（）

要终止内部的线程，`ExecutorService`请调用其`shutdown()`方法。该`ExecutorService`立即将不会关闭，但将不再接受新的任务，而一旦所有线程都完成当前任务后，`ExecutorService`将关闭。提交到`ExecutorService`before的所有任务`shutdown()`都将被执行。这是执行Java `ExecutorService`关闭的示例：

```
executorService.shutdown（）;
```



##### shutdownNow（）

如果要`ExecutorService`立即关闭，则可以调用该`shutdownNow()` 方法。这将尝试立即停止所有正在执行的任务，并跳过所有已提交但未处理的任务。不能保证执行任务。也许他们停下来，也许执行到最后。这是尽力而为的尝试。这是一个调用示例`ExecutorService` `shutdownNow`：

```
executorService.shutdownNow（）;
```



##### awaitTermination（）

该`ExecutorService` `awaitTermination()`方法将阻塞调用它的线程，直到`ExecutorService`完全关闭它，或者直到给定的超时发生为止。`awaitTermination()`通常在调用`shutdown()`或 之后调用该方法`shutdownNow()`。这是一个调用示例`ExecutorService` `awaitTermination()`：

```
executorService.shutdown（）;

executorService.awaitTermination（）;
```



## callable

Java `Callable`接口`java.util.concurrent.Callable`表示可以由单独的线程执行的异步任务。例如，可以将一个`Callable`对象提交给[Java ExecutorService](http://tutorials.jenkov.com/java-util-concurrent/executorservice.html)，该对象随后将异步[执行](http://tutorials.jenkov.com/java-util-concurrent/executorservice.html)该对象。



### Java可调用接口定义

Java `Callable`接口非常简单。它包含一个名为的方法`call()`。这是`Callable`界面的外观（大约）：

```
公共接口Callable <V> {

    V call（）抛出异常；

}
```

`call()`调用 该方法以执行异步任务。该`call()` 方法可以返回结果。如果任务是异步执行的，则结果通常会通过[Java Future](http://tutorials.jenkov.com/java-util-concurrent/java-future.html)传播回任务的创建者。当a `Callable`提交给a `ExecutorService`并发执行时就是这种情况 。

如果任务在执行过程中失败， 该`call()`方法也可能引发`Exception`。



### 实现可调用

这是实现Java `Callable`接口的简单示例：

```
公共类MyCallable实现Callable <String> {

    @Override
    公共字符串call（）引发异常{
        返回String.valueOf（System.currentTimeMillis（））;
    }
}
```

此实现非常简单。它的通用类型设置为[Java String](http://tutorials.jenkov.com/java/strings.html)。结果是该`call()`方法将返回一个String。该`call()` 实现仅返回当前时间的String表示（以毫秒为单位）。在实际的应用程序中，任务可能是一组更复杂或更大型的操作。

IO操作（例如从磁盘或网络读取或写入磁盘或网络）通常是可以同时执行的任务的理想选择。IO操作在读取和写入数据块之间通常需要很长的等待时间。通过在单独的线程中执行此类任务，可以避免不必要地阻塞主应用程序线程。



### 可调用与可运行

Java `Callable`接口与Java 接口相似`Runnable`，因为它们都表示打算由单独的线程同时执行的任务。

Java `Callable`与Java 的不同之处`Runnable`在于，`Runnable`接口的 `run()`方法不返回值，并且不能引发检查的异常（仅`RuntimeException`s）。

另外，a `Runnable`最初是为长时间运行的并发执行而设计的，例如，并发运行网络服务器或监视目录中的新文件。该`Callable`接口更适合用于一次性返回单个结果的任务。



## future

一个Java *的未来*，`java.util.concurrent.Future`代表异步计算的结果。创建异步任务后，将`Future`返回一个Java 对象。该`Future`对象用作异步任务结果的句柄。异步任务完成后，可以通过`Future`启动任务时返回的对象访问结果。

Java的一些内置并发实用程序（例如[Java ExecutorService）](http://tutorials.jenkov.com/java-util-concurrent/executorservice.html)`Future`从其某些方法中返回Java 对象。对于`ExecutorService`，`Future`当您提交`Callable`使其并发（异步）执行时，它将返回a 。



### Java Future接口定义

要了解Java `Future`接口是如何工作的，这里是接口定义的近似值：

```
公共接口Future <V> {
    boolean cancel（boolean mayInterruptIfRunning）
    V get（）;
    V get（长超时，TimeUnit单位）；
    boolean isCancelled（）;
    boolean isDone（）;
}
```

这些方法中的每一个都将在后面的部分中介绍-但您可以看到，Java `Future` 接口不是那么高级。



### 从未来获得结果

如前所述，Java `Future`表示异步任务的结果。要获得结果，请在上调用两种`get()`方法之一`Future`。这些`get()` 方法都返回`Object`，但返回类型也可以是通用的返回类型（意味着特定类的对象，而不仅仅是`Object`）。这是一个`Future`通过Java `get()`方法从Java获取结果的示例：

```
Future future = ... //通过启动异步任务获取Future

//做其他事情，直到准备通过Future检查结果

//从Future获取结果
尝试{
    对象结果= future.get（）;
} catch（InterruptedException e）{
    e.printStackTrace（）;
} catch（ExecutionException e）{
    e.printStackTrace（）;
}
```

如果您`get()`在异步任务完成之前调用该方法，则该`get()` 方法将阻塞直到结果准备就绪。

该方法的一个版本`get()`可以在经过一定时间后超时，您可以通过方法参数来指定。这是调用该`get()`版本的示例：

```
尝试{
    对象结果=
        future.get（1000，TimeUnit.MILLISECONDS）;
} catch（InterruptedException e）{

} catch（ExecutionException e）{

} catch（TimeoutException e）{
    //如果超时时间间隔过去则抛出
    //在结果可用之前。
}
```

上面的示例最多等待1000毫秒，结果才能在中显示`Future`。如果在1000毫秒内没有结果可用，`TimeoutException`则抛出a。



### 通过将来的取消任务cancel（）

您可以`Future`通过调用`Future` `cancel()`方法取消由Java 实例 表示的异步任务。必须实现异步任务执行以支持取消。没有这种支持，呼叫`cancel()`将无效。这是通过Java `Future` `cancel()`方法取消任务的示例：

```
future.cancel（）;
```



### 检查任务是否完成

您可以通过调用`Future` `isDone()`方法来检查异步任务是否已完成（以及结果是否可用）。这是调用Java `Future` `isDone()` 方法的示例：

```
未来未来= ... //从某处获取未来

if（future.isDone（））{
    对象结果= future.get（）;
}其他{
    //做其他事情
}
```



### 检查任务是否已取消

还可以检查Java代表的异步任务`Future`是否已取消。您可以通过调用该`Future` `isCancelled()`方法来进行检查。这是检查任务是否被取消的示例：

```
未来未来= ... //从某处获取未来

if（future.isCancelled（））{

}其他{

}
```