# 引言

## 前置知识
学习本次课程需要
* 具备线程、进程、多线程基本概念
* 对并发模型有基本的了解

## 学习目的
应用程序中使用多线程的一些最常见原因是：
1. 更好地利用CPU  
最常见的原因之一是能够更好地利用计算机中的资源。例如，如果一个线程正在等待对通过网络发送的请求的响应，则另一线程可以同时使用CPU来执行其他操作。此外，如果计算机具有多个CPU，或者CPU具有多个执行核心，则多线程还可以帮助应用程序利用这些额外的CPU核心。
2. 提高响应能力获得更好的用户体验  
如果单击应用程序中的按钮，触发文件读取或网络传输等比较耗时的动作，我们更希望这样的动作可以由线程在后台执行，这样按钮可以快速对用户点击做出反馈，用户的体验更好。而不是等待动作完成之后反馈，这样给用户的感觉是程序在点击按钮之后卡顿了一段时间之后才有反映。
3. 公平的服务多用户  
多线程可以帮助用户之间更公平地共享计算机资源。例如，假设一台服务器接收来自客户端的请求，并且客户端发送的请求要花很长时间才能处理完成，如果只有一个线程来执行这些请求，那么所有其他客户端的请求都必须等待，直到前一个客户端请求完成。通过让每个客户端的请求都由一个独立的线程执行，来避免一个任务完全垄断CPU。


## 课程结构


## 学习目标
经过本次课学习，可以达到
* 可以创建多线程程序
* 了解多线程程序运行时可能出现的问题以及规避方式

# java线程基础

## 线程状态

在Java中，程序运行需要首先启动java虚拟机，一个运行的java虚拟机对应一个java程序进程，而线程位于同一个JVM中，并且可以由Java应用程序在运行时动态创建和停止。每个程序至少有一个线程：主线程。这个主线程是在每个Java应用程序启动期间创建的，它是调用main()程序方法的那个线程。从这个线程开始，Java应用程序可以创建新的线程并使用它们。

每个线程都有一个标识符，该标识符在JVM中是唯一的。线程的名称有助于在监视运行中的JVM的外部应用程序（例如调试器或JConsole工具）中找到某些线程。当执行多个线程时，优先级决定下一个应该执行的任务。

并非所有线程实际上都同时执行，而是将每个CPU内核上的执行时间划分为小片，并将下一个时间片分配给具有最高优先级的下一个等待线程。JVM的调度程序根据线程的优先级确定下一个要执行的线程。

在优先级旁边，线程还具有状态，可以是以下状态之一：

* NEW: 尚未启动的线程处于此状态.
* RUNNABLE: 在Java虚拟机中执行的线程处于此状态。
* BLOCKED: 处于等待监视器锁定状态的被阻塞线程处于此状态。
* WAITING: 无限期等待另一个线程执行特定操作的线程处于此状态。
* TIMED_WAITING: 个正在等待另一个线程执行操作的线程最多达到指定的等待时间，该线程处于此状态。
* TERMINATED: 退出的线程处于此状态。



## 显示主线程相关信息

```
public class MainThread {
     
    public static void main(String[] args) {
        long id = Thread.currentThread().getId();
        String name = Thread.currentThread().getName();
        int priority = Thread.currentThread().getPriority();
        State state = Thread.currentThread().getState();
        String threadGroupName = Thread.currentThread().getThreadGroup().getName();
        System.out.println("id="+id+"; name="+name+"; priority="+priority+"; state="+state+"; threadGroupName="+threadGroupName);
    }
```


## 创建和启动Java线程
创建和启动线程
用Java创建线程是这样完成的：

```
Thread thread = new Thread();
```

要启动Java线程，将调用其start()方法，如下所示：

```
thread.start();
```

本示例未指定要线程需要执行任何代码。因此，线程在启动后将立即再次停止。

有两种方法可以指定线程需要执行的代码。第一种是创建`Thread`的子类并覆盖该`run()`方法。第二种方法是将实现的对象`Runnable` （java.lang.Runnable传递给 `Thread`构造函数。下面介绍这两种方法。

### Thread子类
指定线程运行什么代码的第一种方法是创建Thread的子类并重写该`run()`方法。该run()方法是调用后线程执行的操作start()。这是创建Java Thread子类的示例：

```
 public class MyThread extends Thread {

    public void run(){
       System.out.println("MyThread running");
    }
  }
```
要创建并启动上述线程，您可以执行以下操作：

```
MyThread myThread = new MyThread();
  myTread.start();
```
start()线程启动后 ，调用将立即返回。它不会等到run()方法完成。该`run()`方法像启动了另一个程序一样开始执行。该run()方法执行时，将打印出文本“ MyThread running”。

您也可以创建一个匿名子类，Thread如下所示：
```
Thread thread = new Thread(){
    public void run(){
      System.out.println("Thread Running");
    }
  }

  thread.start();
```
一旦run()新线程执行了该方法，此示例将打印出文本“ Thread running” 。

### 使用接口创建线程
指定线程应运行什么代码的第二种方法是通过创建实现该java.lang.Runnable接口的类。实现该Runnable接口的Java对象 可以由Java执行Thread。本教程的稍后部分将介绍如何完成此操作。

该Runnable接口是Java平台随附的标准Java接口。该Runnable接口只有一个方法run()。Runnable界面基本上是这样的：

```
public interface Runnable() {

    public void run();

}
```

该run()方法的实现中必须包括线程在执行时应该执行的操作。有三种实现Runnable接口的方法：

* 创建一个实现该Runnable接口的Java类。
* 创建一个实现该Runnable接口的匿名类。
* 创建一个实现Runnable接口的Java Lambda 。

以下各节将说明所有这三个选项。

#### Java类实现可运行  
实现Java Runnable接口的第一种方法是创建自己的实现该Runnable接口的Java类。这是实现Runnable接口的自定义Java类的示例：

```
 public class MyRunnable implements Runnable {

    public void run(){
       System.out.println("MyRunnable running");
    }
  }
```
此Runnable实现的全部作用是打印出文本 MyRunnable running。打印完该文本后，该run()方法退出，并且运行该run()方法的线程将停止。

#### Runnable的匿名实现
您还可以创建的匿名实现Runnable。这是实现Runnable接口的匿名Java类的示例：

```
Runnable myRunnable =
    new Runnable(){
        public void run(){
            System.out.println("Runnable running");
        }
    }
```
除了是一个匿名类之外，该示例与使用自定义类实现Runnable接口的示例非常相似。

#### Java Lambda可运行的实现
实现Runnable接口的第三种方法是通过创建接口的 Java Lambda实现Runnable。这是可能的，因为该Runnable接口仅具有单个未实现的方法，因此实际上（尽管可能是无意地）是 功能性Java接口。

这是实现Runnable接口的Java lambda表达式的示例：

```
Runnable runnable =
        () -> { System.out.println("Lambda Runnable running"); };
```

#### 用可运行的线程启动线程
要让该run()方法由线程执行，请在其构造函数中Runnable传递实现接口的类，匿名类或lambda表达式的实例Thread。这是完成的方式：

```
Runnable runnable = new MyRunnable(); // or an anonymous class, or lambda...

Thread thread = new Thread(runnable);
thread.start();
```
当线程启动时，它将调用 实例的run()方法，MyRunnable而不是执行其自己的run()方法。上面的示例将打印出文本“ MyRunnable running”。

### 使用哪种方式

对于这两种方法中哪一种最好没有任何规则。两种方法都有效。不过，就我个人而言，我更喜欢实现Runnable，并将实现的一个Thread实例交给一个实例。当Runnable由线程池执行时，很容易将Runnable 实例排队，直到池中的线程空闲为止。Thread子类很难做到这一点。

有时您可能必须实现Runnable子类Thread。例如，如果创建的子类Thread可以执行多个Runnable。实现线程池时通常是这种情况。

## Thread常用API

### 常见陷阱：调用run（）而不是start（）
创建和启动线程时，常见的错误是调用而不是的run()方法，如下所示： Threadstart()

```
 Thread newThread = new Thread(MyRunnable());
  newThread.run();  //should be start();
```
刚开始您可能不会注意到任何事情，因为Runnable的run()方法按预期执行。但是，它不会由您刚刚创建的新线程执行。而是run()由创建线程的线程执行该方法。换句话说，该线程执行了以上两行代码。要使新创建的线程调用实例的 run()方法，必须调用该方法。 MyRunnablenewThreadnewThread.start()

### 线程名称
创建Java线程时，可以为其命名。该名称可以帮助您区分不同的线程。例如，如果有多个线程写入， System.out可以很方便地查看哪个线程写入了文本。这是一个例子：

```
 Thread thread = new Thread("New Thread") {
      public void run(){
        System.out.println("run by: " + getName());
      }
   };


   thread.start();
   System.out.println(thread.getName());
```


注意作为参数传递给Thread构造函数的字符串“ New Thread” 。此字符串是线程的名称。可以通过Thread的getName()方法获取名称。您也可以Thread在使用Runnable实现时将名称传递给。看起来是这样的：

 ```
 MyRunnable runnable = new MyRunnable();
   Thread thread = new Thread(runnable, "New Thread");

   thread.start();
   System.out.println(thread.getName());
 ```
但是请注意，由于MyRunnable该类不是的子类 Thread，因此它无权访问getName()执行它的线程的方法。

### Thread.currentThread（）
该Thread.currentThread()方法返回对Thread执行实例 的引用currentThread()。这样，您可以访问Thread代表执行给定代码块的线程的Java 对象。这是一个使用方法的例子Thread.currentThread()：

```
Thread thread = Thread.currentThread();
```
一旦有了对Thread对象的引用，就可以在其上调用方法。例如，您可以获取当前正在执行代码的线程的名称，如下所示：

```
 String threadName = Thread.currentThread().getName();
```
## Java线程示例
这是一个小例子。首先，它打印出执行该main()方法的线程的名称。该线程由JVM分配。然后启动10个线程，并给它们一个全名（"" + i）。然后，每个线程将其名称打印出来，然后停止执行。

```
public class ThreadExample {

  public static void main(String[] args){
    System.out.println(Thread.currentThread().getName());
    for(int i=0; i<10; i++){
      new Thread("" + i){
        public void run(){
          System.out.println("Thread: " + getName() + " running");
        }
      }.start();
    }
  }
}
```

请注意，即使线程按顺序启动（1、2、3等），它们也可能不会顺序执行，这意味着线程1可能不是第一个将其名称写入的线程System.out。这是因为线程原则上是并行执行而不是顺序执行。JVM和/或操作系统确定线程的执行顺序。此顺序不必与开始时的顺序相同。



# 线程安全
可同时由多个线程安全调用的代码称为线程安全。如果一段代码是线程安全的，那么不会出现竞争的情况。

接下来要说明线程安全的相关概念

## 临界区
如果多个线程访问一个代码段，这些线程对代码段语句执行的顺序将影响最后的执行结果，那么这个代码段就叫做临界区（Critical Sections）。

当每个线程执行其内部代码的时候，其本身不会引起任何问题；引起问题的原因是对共享资源的使用。例如共用的内存（变量、数组和对象等）、系统资源（数据库、网络服务等）或者是文件。

跟进一步，事实上只有写共享资源操作才会引发问题。只要不进行修改，让多个线程读取相同的资源是安全的。

下面是一个临界区的 Java 代码示例
```
public class Counter {

    protected long count = 0;

    public void add(long value){
        this.count = this.count + value;
    }
}
```
例子中如果多个线程同时运行同一个Couner对象的add方法，产生的结果可能和预期值不符

现在假设两个线程 A 和 B 调用同一个Counter对象进行 add 操作，没有办法知道操作系统何时在两个线程间切换。 add()方法不是一步就可以执行完成的，而是按步骤执行的，代码会被细分为一系列更小的指令执行：

将 this.count 从内存中读到寄存器中
将 value 与寄存器中的数据相加并存入寄存器
将寄存器数据写入内存
那么现在考虑如下的线程 A 和 B 的执行情况：

this.count = 0;
B: 将 this.count 读入一个寄存器 (0) 
A: 将 this.count 读入一个寄存器 (0)
B: 将寄存器中的数据 +2 (2)
B: 将寄存器中的数据 (2) 写回内存，此时 this.count 等于 2
A: 将寄存器中的数据 +3 (3)
A: 将寄存器中的数据 (3) 写回内存，此时 this.count 等于 3
这两个线程的本来目的是将 2 和 3 加到 counter 上，所以期待的结果应该是 5。然而实际运行中线程发生了交错，导致结果与预期不同。上例中，两个线程都将 0 从内存中读出并且加上了 2 和 3，然后将其写回内存。所以最后的结果取决于谁最后将结果写回内存（2 和 3 都有可能）。

## 竞争
“竞争”是可能发生在“临界区”内的一种特使情况。如果临界区的执行结果受到多线程执行顺序的影响，那么就说存在竞争。竞争比喻了不同的线程互相争抢临界区的代码，并且争抢的结果也将影响临界区的运行结果。

前面例子的 add() 方法中存在着临界区，所以当多线程执行临界区代码的时候，就发生了竞争

## 共享资源
仅当多个线程更新共享资源时，才会出现争用条件。因此，为了保证线程安全，需要知道Java线程在执行时共享哪些资源

### 局部变量
局部变量存储在每个线程自己的堆栈中。这意味着局部变量永远不会在线程之间共享。这也意味着所有本地原始变量都是线程安全的。这是线程安全的本地原始变量的示例：
```
public void someMethod(){

  long threadSafeInt = 0;

  threadSafeInt++;
}
```
### 对象引用
对于线程内的对象引用变量是为共享的。但是，引用的对象并不是存储在每个线程的本地堆栈中。所有对象都存储在共享堆中。

如果线程内部创建的对象不会被其他线程引用，则该线程是安全的。

这是线程安全本地对象的示例：

```
public void someMethod(){

  LocalObject localObject = new LocalObject();

  localObject.callMethod();
  method2(localObject);
}

public void method2(LocalObject localObject){
  localObject.setValue("value");
}
```

LocalObject此示例中 的实例不是从方法返回的，也不会传递给可从someMethod()方法外部访问的任何其他对象。每个执行该someMethod()方法的线程都会创建自己的LocalObject 实例，并将其分配给localObject引用。因此，LocalObject此处的使用是线程安全的。

实际上，整个方法someMethod()都是线程安全的。即使将该 LocalObject实例作为参数传递给同一类或其他类中的其他方法，使用它也是线程安全的。

当然，唯一的例外是，如果使用LocalObjectas参数调用的方法之一以LocalObject 允许从其他线程访问它的方式存储实例。

### 对象成员变量
对象成员变量（字段）与对象一起存储在堆中。因此，如果两个线程在同一个对象实例上调用一个方法，并且此方法更新对象成员变量，则该方法不是线程安全的。这是一个不是线程安全的方法的示例：

```
public class NotThreadSafe{
    StringBuilder builder = new StringBuilder();

    public add(String text){
        this.builder.append(text);
    }
}
```
如果两个线程在同一个NotThreadSafe实例上add()同时调用该方法，则它将导致争用条件。例如：

```
NotThreadSafe sharedInstance = new NotThreadSafe();

new Thread(new MyRunnable(sharedInstance)).start();
new Thread(new MyRunnable(sharedInstance)).start();

public class MyRunnable implements Runnable{
  NotThreadSafe instance = null;

  public MyRunnable(NotThreadSafe instance){
    this.instance = instance;
  }

  public void run(){
    this.instance.add("some text");
  }
}
```
请注意，两个MyRunnable实例如何共享同一NotThreadSafe实例。因此，当他们add()在NotThreadSafe实例上调用该方法时，将导致争用条件。

但是，如果两个线程在不同实例上add()同时调用该方法 ，则不会导致争用条件。这是之前的示例，但稍作修改：

```
new Thread(new MyRunnable(new NotThreadSafe())).start();
new Thread(new MyRunnable(new NotThreadSafe())).start();
```
现在，两个线程各自具有自己的实例，NotThreadSafe因此它们对add方法的调用不会互相干扰。该代码不再具有竞争条件。因此，即使一个对象不是线程安全的，它仍然可以以不会导致竞争状态的方式使用。

## 不可变类
仅当多个线程正在访问同一资源并且一个或多个线程写入该资源时，才会发生争用条件。如果多个线程读取相同的资源 竞争条件，则不会发生。

通过使共享对象不可变，从而确保线程安全，可以确保线程之间共享的对象不会被任何线程更新。这是一个例子
```
public class ImmutableValue{

  private int value = 0;

  public ImmutableValue(int value){
    this.value = value;
  }

  public int getValue(){
    return this.value;
  }
}
```

注意ImmutableValue实例的值如何在构造函数中传递。还请注意，没有设置方法。一旦ImmutableValue实例被创建，你不能改变它的值。这是一成不变的。但是，您可以使用getValue()方法阅读它。

如果需要对ImmutableValue实例执行操作，可以通过返回一个新实例以及该操作产生的值来执行。这是添加操作的示例：
```
public class ImmutableValue{

  private int value = 0;

  public ImmutableValue(int value){
    this.value = value;
  }

  public int getValue(){
    return this.value;
  }

  
  public ImmutableValue add(int valueToAdd){
    return new ImmutableValue(this.value + valueToAdd);
  }
}
```
注意，该add()方法如何ImmutableValue使用添加操作的结果返回新实例，而不是将值添加到自身。

# 锁机制

## 同步代码块
Java同步块将方法或代码块标记为已同步。Java同步块可用于避免竞争条件，用于编写线程安全的代码。

### synchronized关键字
Java中的同步块用synchronized关键字标记。Java中的同步块在某些对象上同步。在同一个对象上同步的所有同步块只能在其中一个内部同时执行一个线程。尝试进入同步块的所有其他线程将被阻塞，直到同步块内的线程退出该块为止。

的synchronized关键字可以被用于标记四种不同类型的块：

* 实例方法
* 静态方法
* 实例方法中的代码块
* 静态方法中的代码块

这些块在不同的对象上同步。您需要哪种类型的同步块取决于具体情况。

### 同步实例方法
这是一个同步实例方法：

```
public synchronized void add(int value){
      this.count += value;
  }
```
注意synchronized方法声明中关键字的使用。这告诉Java该方法是同步的。

Java中的同步实例方法在拥有该方法的实例（对象）上同步。因此，每个实例在不同的对象（拥有实例）上具有同步的同步方法。在同步实例方法内部只能执行一个线程。如果存在多个实例，则每个实例一次可以在一个同步实例方法中执行一个线程。每个实例一个线程。

同步静态方法
静态方法被标记为已同步，就像使用synchronized关键字的实例方法一样 。这是一个Java同步静态方法示例：

```
public static synchronized void add(int value){
      count += value;
  }
```
同样，这里的synchronized关键字告诉Java方法是同步的。

同步静态方法在同步静态方法所属类的类对象上同步。由于每个类的Java VM中仅存在一个类对象，因此同一类中的静态同步方法中只能执行一个线程。

如果静态同步方法位于不同的类中，则一个线程可以在每个类的静态同步方法中执行。每个类一个线程，无论它调用哪种静态同步方法。

实例方法中的同步块
您不必同步整个方法。有时最好只同步方法的一部分。方法内部的Java同步块使这成为可能。

这是未同步的Java方法中的Java代码的同步块：

```
  public void add(int value){

    synchronized(this){
       this.count += value;   
    }
  }
```
本示例使用Java同步块构造将代码块标记为已同步。现在，该代码将像执行同步方法一样执行。

请注意，Java同步块构造如何在括号中使用对象。在示例“ this”中，使用了add方法。同步结构在括号中使用的对象称为监视对象。据说该代码已在监视对象上同步。同步实例方法将其所属的对象用作监视对象。

在同一监视对象上同步的Java代码块内只能执行一个线程。

以下两个示例都在调用它们的实例上同步。因此，它们在同步方面是等效的：


```
  public class MyClass {
  
    public synchronized void log1(String msg1, String msg2){
       log.writeln(msg1);
       log.writeln(msg2);
    }

  
    public void log2(String msg1, String msg2){
       synchronized(this){
          log.writeln(msg1);
          log.writeln(msg2);
       }
    }
  }
```
因此，在此示例中，只有一个线程可以在两个同步块中的任何一个内部执行。

如果第二个同步块已在与上不同的对象上同步this，则每次可以在每个方法中执行一个线程。

### 静态方法中的同步块
这是与静态方法相同的两个示例。这些方法在该方法所属的类的class对象上同步：

```
  public class MyClass {

    public static synchronized void log1(String msg1, String msg2){
       log.writeln(msg1);
       log.writeln(msg2);
    }

  
    public static void log2(String msg1, String msg2){
       synchronized(MyClass.class){
          log.writeln(msg1);
          log.writeln(msg2);  
       }
    }
  }
```
在这两个方法中的任何一个中只能同时执行一个线程。

如果第二个同步块已在之外的其他对象上同步MyClass.class，则一个线程可以在每个方法中同时执行。

### Java同步示例
这是一个示例，该示例启动2个线程，并让它们都在Counter的同一实例上调用add方法。一次仅一个线程将能够在同一实例上调用add方法，因为该方法在它所属的实例上是同步的。

```
  public class Counter{
     
     long count = 0;
    
     public synchronized void add(long value){
       this.count += value;
     }
  }
  public class CounterThread extends Thread{

     protected Counter counter = null;

     public CounterThread(Counter counter){
        this.counter = counter;
     }

     public void run() {
	for(int i=0; i<10; i++){
           counter.add(i);
        }
     }
  }
  public class Example {

    public static void main(String[] args){
      Counter counter = new Counter();
      Thread  threadA = new CounterThread(counter);
      Thread  threadB = new CounterThread(counter);

      threadA.start();
      threadB.start(); 
    }
  }
```
创建两个线程。相同的Counter实例将在其构造函数中传递给它们两个。该Counter.add()方法在实例上同步，因为add方法是实例方法，并标记为已同步。因此，只有一个线程可以一次调用add（）方法。另一个线程将等到第一个线程离开add（）方法之后才能执行该方法本身。

如果两个线程引用了两个单独的Counter实例，则同时调用add（）方法将没有问题。调用本来是对不同的对象的，所以调用的方法也将在不同的对象（拥有该方法的对象）上同步。因此，通话不会阻塞。看起来是这样的：

```
  public class Example {

    public static void main(String[] args){
      Counter counterA = new Counter();
      Counter counterB = new Counter();
      Thread  threadA = new CounterThread(counterA);
      Thread  threadB = new CounterThread(counterB);

      threadA.start();
      threadB.start(); 
    }
  }
```
请注意，线程A和线程B这两个线程不再引用相同的计数器实例。该add方法 counterA和counterB是在他们的两个拥有实例同步。因此，调用add()on counterA不会阻止对add() on 的调用counterB。

### Java并发实用程序
该synchronized机制是Java的第一种用于同步访问多个线程共享的对象的机制。该synchronized机制不是很先进。这就是Java 5拥有一整套并发实用程序类 来帮助开发人员实现比您所获得的更细粒度的并发控制的原因synchronized。

## 锁


# 线程间协作


# 停止线程
## 暂停线程
线程可以通过调用static方法来暂停自身Thread.sleep()。在sleep() 需要数毫秒作为参数。该sleep()方法将尝试在恢复执行之前休眠该毫秒数。线程sleep()不是100％精确的，但还是很不错的。这是通过调用Thread sleep()方法将Java线程暂停3秒（3.000毫秒）的示例：

```
try {
    Thread.sleep(10L * 1000L);
} catch (InterruptedException e) {
    e.printStackTrace();
}
```
执行上述Java代码的线程将休眠大约10秒钟（10.000毫秒）。

## 停止线程
停止Java线程需要一些线程实现代码的准备。Java Thread类包含一个stop()方法，但已弃用。原始stop() 方法无法保证线程在什么状态下停止。这意味着，线程在执行过程中可以访问的所有Java对象将处于未知状态。如果您的应用程序中的其他线程也可以访问相同的对象，则您的应用程序可能会意外失败并且无法预期。

不该stop()方法，必须手动实现停止该线程的代码。这是一个实现的类示例，Runnable其中包含一个称为的额外方法doStop()，该方法 向Runnable发出停止信号。该Runnable会检查这个信号，并停止当它准备这样做。

```
public class MyRunnable implements Runnable {

    private boolean doStop = false;

    public synchronized void doStop() {
        this.doStop = true;
    }

    private synchronized boolean keepRunning() {
        return this.doStop == false;
    }

    @Override
    public void run() {
        while(keepRunning()) {
            // keep doing what this thread should do.
            System.out.println("Running");

            try {
                Thread.sleep(3L * 1000L);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

        }
    }
}
```
注意doStop()和keepRunning()方法。在doStop()旨在被从另一个线程小于线程执行被调用MyRunnable的run() 方法。该keepRunning()方法由执行MyRunnable的run()方法的线程在内部调用 。只要doStop()尚未调用，该keepRunning()方法就会返回true-意味着执行该run()方法的线程 将继续运行。

这是一个启动Java线程的示例，该线程执行上述MyRunnable 类的实例，并在延迟后再次停止它：

```
public class MyRunnableMain {

    public static void main(String[] args) {
        MyRunnable myRunnable = new MyRunnable();

        Thread thread = new Thread(myRunnable);

        thread.start();

        try {
            Thread.sleep(10L * 1000L);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        myRunnable.doStop();
    }
}
```
本示例首先创建一个MyRunnable实例，然后将该实例传递给线程并启动该线程。然后执行该main()方法的线程（主线程）休眠10秒钟，然后调用实例的doStop()方法MyRunnable。这将导致执行该MyRunnable方法的线程停止，因为keepRunning()将true在after之后返回doStop()。

请记住，如果您的Runnable实现不仅需要 run()方法（例如a stop()或pause()方法），那么您将无法再Runnable使用Java lambda表达式创建实现。Java lambda只能实现一个方法。取而代之的是，您必须使用自定义类或扩展的自定义接口，该类 Runnable具有额外的方法，并且由匿名类实现。